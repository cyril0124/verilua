---@diagnostic disable: redundant-parameter
----------------------------------------------------
-- Auto generated by gen_chdl_access.tl
-- DO NOT edit this file!
----------------------------------------------------

--[[luajit-pro, pretty, {IS_SINGLE = 1, IS_DOUBLE = 0, IS_MULTI = 0}]] local vpiml = require("vpiml")
local BitVec = require("BitVec")
local table_new = require("table.new")

local assert = assert
local f = string.format

local chdl, chdl_array
chdl = {
	get = function(this)
		assert(false, f("<chdl>:get() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	get64 = function(this)
		assert(false, f("<chdl>:get64() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set = function(this)
		assert(false, f("<chdl>:set() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_imm = function(this)
		assert(false, f("<chdl>:set_imm() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_unsafe = function(this)
		assert(false, f("<chdl>:set_unsafe() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_imm_unsafe = function(this)
		assert(false, f("<chdl>:set_imm_unsafe() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_cached = function(this)
		assert(false, f("<chdl>:set_cached() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_imm_cached = function(this)
		assert(false, f("<chdl>:set_imm_cached() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_bitfield = function(this)
		assert(false, f("<chdl>:set_bitfield() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_imm_bitfield = function(this)
		assert(false, f("<chdl>:set_imm_bitfield() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_bitfield_hex_str = function(this)
		assert(false, f("<chdl>:set_bitfield_hex_str() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_imm_bitfield_hex_str = function(this)
		assert(false, f("<chdl>:set_imm_bitfield_hex_str() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_force = function(this)
		assert(false, f("<chdl>:set_force() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_imm_force = function(this)
		assert(false, f("<chdl>:set_imm_force() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_release = function(this)
		assert(false, f("<chdl>:set_release() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_imm_release = function(this)
		assert(false, f("<chdl>:set_imm_release() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
}
chdl_array = {
	at = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	get_index = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_index = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_imm_index = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_index_unsafe = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_imm_index_unsafe = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	get_index_all = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	get_index_bitvec = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_index_bitfield = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_imm_index_bitfield = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_index_bitfield_hex_str = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_imm_index_bitfield_hex_str = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_index_all = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_imm_index_all = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_index_unsafe_all = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_imm_index_unsafe_all = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
}

local function chdl_init()
	chdl.get = function(this, force_multi_beat)
		do
			return vpiml.vpiml_get_value(this.hdl)
		end
	end

	chdl.get64 = function(this)
		do
			return this:get()
		end
	end

	chdl.get_bitvec = function(this)
		do
			if this.bitvec then
				this.bitvec:_update_u32_vec(vpiml.vpiml_get_value(this.hdl))
				return this.bitvec
			else
				this.bitvec = BitVec(vpiml.vpiml_get_value(this.hdl), this.width)
				return this.bitvec
			end
		end
	end

	chdl.set = function(this, value, force_single_beat)
		do
			vpiml.vpiml_set_value(this.hdl, value)
		end
	end
	do --#
		--# Unsafe usage of CallableHDL:set()
		--# Do not check value type and lenght of value table.
		--# Usually has higher performance than CallableHDL:set()
		--#

		chdl.set_unsafe = chdl.set

		chdl.set_cached = function(this, value)
			if this.cached_value == value then
				return
			end

			this.cached_value = value
			vpiml.vpiml_set_value(this.hdl, value)
		end
	end

	chdl.set_bitfield = function(this, s, e, v)
		do
			vpiml.vpiml_set_value(this.hdl, this:get_bitvec():_set_bitfield(s, e, v).u32_vec[1])
		end
	end

	chdl.set_bitfield_hex_str = function(this, s, e, hex_str)
		do
			vpiml.vpiml_set_value(this.hdl, this:get_bitvec():_set_bitfield_hex_str(s, e, hex_str).u32_vec[1])
		end
	end

	chdl.set_force = function(this, value, force_single_beat)
		do
			vpiml.vpiml_force_value(this.hdl, value)
		end
	end

	chdl.set_release = function(this)
		vpiml.vpiml_release_value(this.hdl)
	end
	chdl.set_imm = function(this, value, force_single_beat)
		do
			vpiml.vpiml_set_imm_value(this.hdl, value)
		end
	end
	do --#
		--# Unsafe usage of CallableHDL:set()
		--# Do not check value type and lenght of value table.
		--# Usually has higher performance than CallableHDL:set()
		--#

		chdl.set_imm_unsafe = chdl.set_imm

		chdl.set_imm_cached = function(this, value)
			if this.cached_value == value then
				return
			end

			this.cached_value = value
			vpiml.vpiml_set_imm_value(this.hdl, value)
		end
	end

	chdl.set_imm_bitfield = function(this, s, e, v)
		do
			vpiml.vpiml_set_imm_value(this.hdl, this:get_bitvec():_set_bitfield(s, e, v).u32_vec[1])
		end
	end

	chdl.set_imm_bitfield_hex_str = function(this, s, e, hex_str)
		do
			vpiml.vpiml_set_value(this.hdl, this:get_bitvec():_set_bitfield_hex_str(s, e, hex_str).u32_vec[1])
		end
	end

	chdl.set_imm_force = function(this, value, force_single_beat)
		do
			vpiml.vpiml_force_imm_value(this.hdl, value)
		end
	end

	chdl.set_imm_release = function(this)
		vpiml.vpiml_release_imm_value(this.hdl)
	end
end

local function chdl_array_init()
	chdl_array.at = function(this, idx)
		this.hdl = this.array_hdls[idx + 1]
		return this
	end
	chdl_array.get_index = function(this, index, force_multi_beat)
		do
			local chosen_hdl = this.array_hdls[index + 1]
			return vpiml.vpiml_get_value(chosen_hdl)
		end
	end

	chdl_array.get_index_all = function(this, force_multi_beat)
		do
			local ret = table_new(this.array_size, 0)
			for index = 0, this.array_size - 1 do
				ret[index + 1] = this.get_index(this, index, force_multi_beat)
			end
			return ret
		end
	end

	chdl_array.get_index_bitvec = function(this, index)
		do
			local chosen_hdl = this.array_hdls[index + 1]
			if this.array_bitvecs[index + 1] then
				this.array_bitvecs[index + 1]:_update_u32_vec(vpiml.vpiml_get_value(chosen_hdl))
				return this.array_bitvecs[index + 1]
			else
				this.array_bitvecs[index + 1] = BitVec(vpiml.vpiml_get_value(chosen_hdl), this.width)
				return this.array_bitvecs[index + 1]
			end
		end
	end
	chdl_array.set_index = function(this, index, value, force_single_beat)
		local chosen_hdl = this.array_hdls[index + 1]
		do
			vpiml.vpiml_set_value(chosen_hdl, value)
		end
	end
	do
		chdl_array.set_index_unsafe = chdl_array.set_index
	end

	chdl_array.set_index_bitfield = function(this, index, s, e, v)
		local chosen_hdl = this.array_hdls[index + 1]
		do
			vpiml.vpiml_set_value(chosen_hdl, this:get_index_bitvec(index):_set_bitfield(s, e, v).u32_vec[1])
		end
	end

	chdl_array.set_index_bitfield_hex_str = function(this, index, s, e, hex_str)
		local chosen_hdl = this.array_hdls[index + 1]
		do
			vpiml.vpiml_set_value(chosen_hdl, this:get_index_bitvec(index):_set_bitfield_hex_str(s, e, hex_str).u32_vec[1])
		end
	end

	chdl_array.set_index_all = function(this, values, force_single_beat)
		force_single_beat = force_single_beat or false
		for index = 0, this.array_size - 1 do
			this:set_index(index, values[index + 1], force_single_beat)
		end
	end

	chdl_array.set_index_unsafe_all = function(this, values, force_single_beat)
		force_single_beat = force_single_beat or false
		for index = 0, this.array_size - 1 do
			this:set_index_unsafe(index, values[index + 1], force_single_beat)
		end
	end
	chdl_array.set_imm_index = function(this, index, value, force_single_beat)
		local chosen_hdl = this.array_hdls[index + 1]
		do
			vpiml.vpiml_set_imm_value(chosen_hdl, value)
		end
	end
	do
		chdl_array.set_imm_index_unsafe = chdl_array.set_imm_index
	end

	chdl_array.set_imm_index_bitfield = function(this, index, s, e, v)
		local chosen_hdl = this.array_hdls[index + 1]
		do
			vpiml.vpiml_set_imm_value(chosen_hdl, this:get_index_bitvec(index):_set_bitfield(s, e, v).u32_vec[1])
		end
	end

	chdl_array.set_imm_index_bitfield_hex_str = function(this, index, s, e, hex_str)
		local chosen_hdl = this.array_hdls[index + 1]
		do
			vpiml.vpiml_set_imm_value(chosen_hdl, this:get_index_bitvec(index):_set_bitfield_hex_str(s, e, hex_str).u32_vec[1])
		end
	end

	chdl_array.set_imm_index_all = function(this, values, force_single_beat)
		force_single_beat = force_single_beat or false
		for index = 0, this.array_size - 1 do
			this:set_imm_index(index, values[index + 1], force_single_beat)
		end
	end

	chdl_array.set_imm_index_unsafe_all = function(this, values, force_single_beat)
		force_single_beat = force_single_beat or false
		for index = 0, this.array_size - 1 do
			this:set_imm_index_unsafe(index, values[index + 1], force_single_beat)
		end
	end
end

return function(is_array)
	chdl_init()

	if is_array then
		chdl_array_init()
		for k, func in pairs(chdl_array) do
			chdl[k] = func
		end
	end

	return chdl
end
