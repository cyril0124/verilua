----------------------------------------------------
-- Auto generated by gen_chdl_access.tl
-- DO NOT edit this file!
----------------------------------------------------

--[[luajit-pro, pretty, {IS_MULTI = 1, IS_DOUBLE = 0, IS_SINGLE = 0}]] local vpiml = require("vpiml")
local BitVec = require("BitVec")
local table_new = require("table.new")

local assert = assert
local f = string.format

local chdl, chdl_array
chdl = {
	get = function(this)
		assert(false, f("<chdl>:get() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	get64 = function(this)
		assert(false, f("<chdl>:get64() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set = function(this)
		assert(false, f("<chdl>:set() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_imm = function(this)
		assert(false, f("<chdl>:set_imm() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_unsafe = function(this)
		assert(false, f("<chdl>:set_unsafe() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_imm_unsafe = function(this)
		assert(false, f("<chdl>:set_imm_unsafe() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_cached = function(this)
		assert(false, f("<chdl>:set_cached() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_imm_cached = function(this)
		assert(false, f("<chdl>:set_imm_cached() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_bitfield = function(this)
		assert(false, f("<chdl>:set_bitfield() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_imm_bitfield = function(this)
		assert(false, f("<chdl>:set_imm_bitfield() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_bitfield_hex_str = function(this)
		assert(false, f("<chdl>:set_bitfield_hex_str() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_imm_bitfield_hex_str = function(this)
		assert(false, f("<chdl>:set_imm_bitfield_hex_str() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_force = function(this)
		assert(false, f("<chdl>:set_force() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_imm_force = function(this)
		assert(false, f("<chdl>:set_imm_force() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_release = function(this)
		assert(false, f("<chdl>:set_release() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
	set_imm_release = function(this)
		assert(false, f("<chdl>:set_imm_release() is not implemented! fullpath => %s bitwidth => %d", this.fullpath, this.width))
	end,
}
chdl_array = {
	at = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	get_index = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_index = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_imm_index = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_index_unsafe = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_imm_index_unsafe = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	get_index_all = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	get_index_bitvec = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_index_bitfield = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_imm_index_bitfield = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_index_bitfield_hex_str = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_imm_index_bitfield_hex_str = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_index_all = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_imm_index_all = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_index_unsafe_all = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
	set_imm_index_unsafe_all = function(this)
		assert(false, f("Normal handle does not support <chdl>:at(), fullpath => %s bitwidth => %d is_array => %s", this.fullpath, this.width, tostring(this.is_array)))
	end,
}

local function chdl_init()
	chdl.get = function(this, force_multi_beat)
		do
			vpiml.vpiml_get_value_multi(this.hdl, this.c_results, this.beat_num)
			return this.c_results
		end
	end

	chdl.get64 = function(this)
		do
			return vpiml.vpiml_get_value64(this.hdl)
		end
	end

	chdl.get_bitvec = function(this)
		do
			vpiml.vpiml_get_value_multi(this.hdl, this.c_results, this.beat_num)

			if this.bitvec then
				this.bitvec:_update_u32_vec(this.c_results)
				return this.bitvec
			else
				this.bitvec = BitVec(this.c_results, this.width)
				return this.bitvec
			end
		end
	end

	chdl.set = function(this, value, force_single_beat)
		do
			if force_single_beat then
				if type(value) == "table" then
					assert(false)
				end
				vpiml.vpiml_set_value64_force_single(this.hdl, value)
			else
				if type(value) ~= "table" then
					assert(
						false,
						type(value)
							.. " =/= table \n"
							.. this.name
							.. " is a multibeat hdl, <value> should be a multibeat value which is represented as a <table> in verilua or you can call <CallableHDL>:set(<value>, <force_single_beat>) with <force_single_beat> == true, name => "
							.. this.fullpath
					)
				end

				local beat_num = this.beat_num
				if #value ~= beat_num then
					assert(false, "len: " .. #value .. " =/= " .. this.beat_num)
				end

				--# TODO: Check performance
				if beat_num == 3 then
					vpiml.vpiml_set_value_multi_beat_3(this.hdl, value[1], value[2], value[3])
				elseif beat_num == 4 then
					vpiml.vpiml_set_value_multi_beat_4(this.hdl, value[1], value[2], value[3], value[4])
				elseif beat_num == 5 then
					vpiml.vpiml_set_value_multi_beat_5(this.hdl, value[1], value[2], value[3], value[4], value[5])
				elseif beat_num == 6 then
					vpiml.vpiml_set_value_multi_beat_6(this.hdl, value[1], value[2], value[3], value[4], value[5], value[6])
				elseif beat_num == 7 then
					vpiml.vpiml_set_value_multi_beat_7(this.hdl, value[1], value[2], value[3], value[4], value[5], value[6], value[7])
				elseif beat_num == 8 then
					vpiml.vpiml_set_value_multi_beat_8(this.hdl, value[1], value[2], value[3], value[4], value[5], value[6], value[7], value[8])
				else
					for i = 1, this.beat_num do
						this.c_results[i - 1] = value[i]
					end
					vpiml.vpiml_set_value_multi(this.hdl, this.c_results)
				end
			end
		end
	end
	do
		chdl.set_unsafe = function(this, value, force_single_beat)
			--#
			--# Unsafe usage of CallableHDL:set()
			--# Do not check value type and lenght of value table.
			--# Usually has higher performance than CallableHDL:set()
			--#
			if force_single_beat then
				vpiml.vpiml_set_value64_force_single(this.hdl, value)
			else
				--# value is a table where <lsb ... msb>
				local beat_num = this.beat_num

				if beat_num == 3 then
					vpiml.vpiml_set_value_multi_beat_3(this.hdl, value[1], value[2], value[3])
				elseif beat_num == 4 then
					vpiml.vpiml_set_value_multi_beat_4(this.hdl, value[1], value[2], value[3], value[4])
				elseif beat_num == 5 then
					vpiml.vpiml_set_value_multi_beat_5(this.hdl, value[1], value[2], value[3], value[4], value[5])
				elseif beat_num == 6 then
					vpiml.vpiml_set_value_multi_beat_6(this.hdl, value[1], value[2], value[3], value[4], value[5], value[6])
				elseif beat_num == 7 then
					vpiml.vpiml_set_value_multi_beat_7(this.hdl, value[1], value[2], value[3], value[4], value[5], value[6], value[7])
				elseif beat_num == 8 then
					vpiml.vpiml_set_value_multi_beat_8(this.hdl, value[1], value[2], value[3], value[4], value[5], value[6], value[7], value[8])
				else
					for i = 1, this.beat_num do
						this.c_results[i - 1] = value[i]
					end
					vpiml.vpiml_set_value_multi(this.hdl, this.c_results)
				end
			end
		end
	end

	chdl.set_bitfield = function(this, s, e, v)
		do
			local bv = this:get_bitvec():_set_bitfield(s, e, v)
			this:set_unsafe(bv.u32_vec)
		end
	end

	chdl.set_bitfield_hex_str = function(this, s, e, hex_str)
		do
			local bv = this:get_bitvec():_set_bitfield_hex_str(s, e, hex_str)
			this:set_unsafe(bv.u32_vec)
		end
	end

	chdl.set_force = function(this, value, force_single_beat)
		do
			if force_single_beat then
				if type(value) == "table" then
					assert(false)
				end
				vpiml.vpiml_force_value64_force_single(this.hdl, value)
			else
				--# value is a table where <lsb ... msb>
				if type(value) ~= "table" then
					assert(
						false,
						type(value)
							.. " =/= table \n"
							.. this.name
							.. " is a multibeat hdl, <value> should be a multibeat value which is represented as a <table> in verilua or you can call <CallableHDL>:set_force(<value>, <force_single_beat>) with <force_single_beat> == true, name => "
							.. this.fullpath
					)
				end

				local beat_num = this.beat_num
				if #value ~= beat_num then
					assert(false, "len: " .. #value .. " =/= " .. this.beat_num)
				end

				--# TODO: Check performance
				if beat_num == 3 then
					vpiml.vpiml_force_value_multi_beat_3(this.hdl, value[1], value[2], value[3])
				elseif beat_num == 4 then
					vpiml.vpiml_force_value_multi_beat_4(this.hdl, value[1], value[2], value[3], value[4])
				elseif beat_num == 5 then
					vpiml.vpiml_force_value_multi_beat_5(this.hdl, value[1], value[2], value[3], value[4], value[5])
				elseif beat_num == 6 then
					vpiml.vpiml_force_value_multi_beat_6(this.hdl, value[1], value[2], value[3], value[4], value[5], value[6])
				elseif beat_num == 7 then
					vpiml.vpiml_force_value_multi_beat_7(this.hdl, value[1], value[2], value[3], value[4], value[5], value[6], value[7])
				elseif beat_num == 8 then
					vpiml.vpiml_force_value_multi_beat_8(this.hdl, value[1], value[2], value[3], value[4], value[5], value[6], value[7], value[8])
				else
					for i = 1, this.beat_num do
						this.c_results[i - 1] = value[i]
					end
					vpiml.vpiml_force_value_multi(this.hdl, this.c_results)
				end
			end
		end
	end

	chdl.set_release = function(this)
		vpiml.vpiml_release_value(this.hdl)
	end
	chdl.set_imm = function(this, value, force_single_beat)
		do
			if force_single_beat then
				if type(value) == "table" then
					assert(false)
				end
				vpiml.vpiml_set_imm_value64_force_single(this.hdl, value)
			else
				if type(value) ~= "table" then
					assert(
						false,
						type(value)
							.. " =/= table \n"
							.. this.name
							.. " is a multibeat hdl, <value> should be a multibeat value which is represented as a <table> in verilua or you can call <CallableHDL>:set(<value>, <force_single_beat>) with <force_single_beat> == true, name => "
							.. this.fullpath
					)
				end

				local beat_num = this.beat_num
				if #value ~= beat_num then
					assert(false, "len: " .. #value .. " =/= " .. this.beat_num)
				end

				--# TODO: Check performance
				if beat_num == 3 then
					vpiml.vpiml_set_imm_value_multi_beat_3(this.hdl, value[1], value[2], value[3])
				elseif beat_num == 4 then
					vpiml.vpiml_set_imm_value_multi_beat_4(this.hdl, value[1], value[2], value[3], value[4])
				elseif beat_num == 5 then
					vpiml.vpiml_set_imm_value_multi_beat_5(this.hdl, value[1], value[2], value[3], value[4], value[5])
				elseif beat_num == 6 then
					vpiml.vpiml_set_imm_value_multi_beat_6(this.hdl, value[1], value[2], value[3], value[4], value[5], value[6])
				elseif beat_num == 7 then
					vpiml.vpiml_set_imm_value_multi_beat_7(this.hdl, value[1], value[2], value[3], value[4], value[5], value[6], value[7])
				elseif beat_num == 8 then
					vpiml.vpiml_set_imm_value_multi_beat_8(this.hdl, value[1], value[2], value[3], value[4], value[5], value[6], value[7], value[8])
				else
					for i = 1, this.beat_num do
						this.c_results[i - 1] = value[i]
					end
					vpiml.vpiml_set_imm_value_multi(this.hdl, this.c_results)
				end
			end
		end
	end
	do
		chdl.set_imm_unsafe = function(this, value, force_single_beat)
			--#
			--# Unsafe usage of CallableHDL:set()
			--# Do not check value type and lenght of value table.
			--# Usually has higher performance than CallableHDL:set()
			--#
			if force_single_beat then
				vpiml.vpiml_set_imm_value64_force_single(this.hdl, value)
			else
				--# value is a table where <lsb ... msb>
				local beat_num = this.beat_num

				if beat_num == 3 then
					vpiml.vpiml_set_imm_value_multi_beat_3(this.hdl, value[1], value[2], value[3])
				elseif beat_num == 4 then
					vpiml.vpiml_set_imm_value_multi_beat_4(this.hdl, value[1], value[2], value[3], value[4])
				elseif beat_num == 5 then
					vpiml.vpiml_set_imm_value_multi_beat_5(this.hdl, value[1], value[2], value[3], value[4], value[5])
				elseif beat_num == 6 then
					vpiml.vpiml_set_imm_value_multi_beat_6(this.hdl, value[1], value[2], value[3], value[4], value[5], value[6])
				elseif beat_num == 7 then
					vpiml.vpiml_set_imm_value_multi_beat_7(this.hdl, value[1], value[2], value[3], value[4], value[5], value[6], value[7])
				elseif beat_num == 8 then
					vpiml.vpiml_set_imm_value_multi_beat_8(this.hdl, value[1], value[2], value[3], value[4], value[5], value[6], value[7], value[8])
				else
					for i = 1, this.beat_num do
						this.c_results[i - 1] = value[i]
					end
					vpiml.vpiml_set_imm_value_multi(this.hdl, this.c_results)
				end
			end
		end
	end

	chdl.set_imm_bitfield = function(this, s, e, v)
		do
			local bv = this:get_bitvec():_set_bitfield(s, e, v)
			this:set_imm_unsafe(bv.u32_vec)
		end
	end

	chdl.set_imm_bitfield_hex_str = function(this, s, e, hex_str)
		do
			local bv = this:get_bitvec():_set_bitfield_hex_str(s, e, hex_str)
			this:set_imm_unsafe(bv.u32_vec)
		end
	end

	chdl.set_imm_force = function(this, value, force_single_beat)
		do
			if force_single_beat then
				if type(value) == "table" then
					assert(false)
				end
				vpiml.vpiml_force_imm_value64_force_single(this.hdl, value)
			else
				--# value is a table where <lsb ... msb>
				if type(value) ~= "table" then
					assert(
						false,
						type(value)
							.. " =/= table \n"
							.. this.name
							.. " is a multibeat hdl, <value> should be a multibeat value which is represented as a <table> in verilua or you can call <CallableHDL>:set_force(<value>, <force_single_beat>) with <force_single_beat> == true, name => "
							.. this.fullpath
					)
				end

				local beat_num = this.beat_num
				if #value ~= beat_num then
					assert(false, "len: " .. #value .. " =/= " .. this.beat_num)
				end

				--# TODO: Check performance
				if beat_num == 3 then
					vpiml.vpiml_force_imm_value_multi_beat_3(this.hdl, value[1], value[2], value[3])
				elseif beat_num == 4 then
					vpiml.vpiml_force_imm_value_multi_beat_4(this.hdl, value[1], value[2], value[3], value[4])
				elseif beat_num == 5 then
					vpiml.vpiml_force_imm_value_multi_beat_5(this.hdl, value[1], value[2], value[3], value[4], value[5])
				elseif beat_num == 6 then
					vpiml.vpiml_force_imm_value_multi_beat_6(this.hdl, value[1], value[2], value[3], value[4], value[5], value[6])
				elseif beat_num == 7 then
					vpiml.vpiml_force_imm_value_multi_beat_7(this.hdl, value[1], value[2], value[3], value[4], value[5], value[6], value[7])
				elseif beat_num == 8 then
					vpiml.vpiml_force_imm_value_multi_beat_8(this.hdl, value[1], value[2], value[3], value[4], value[5], value[6], value[7], value[8])
				else
					for i = 1, this.beat_num do
						this.c_results[i - 1] = value[i]
					end
					vpiml.vpiml_force_imm_value_multi(this.hdl, this.c_results)
				end
			end
		end
	end

	chdl.set_imm_release = function(this)
		vpiml.vpiml_release_imm_value(this.hdl)
	end
end

local function chdl_array_init()
	chdl_array.at = function(this, idx)
		this.hdl = this.array_hdls[idx + 1]
		return this
	end
	chdl_array.get_index = function(this, index)
		do
			local chosen_hdl = this.array_hdls[index + 1]
			vpiml.vpiml_get_value_multi(chosen_hdl, this.c_results, this.beat_num)
			return this.c_results
		end
	end

	chdl_array.get_index_all = function(this, force_multi_beat)
		do
			local ret = table_new(this.array_size, 0)
			for index = 0, this.array_size - 1 do
				this.get_index(this, index)

				local tmp = table_new(this.beat_num, 0)
				for i = 1, this.beat_num do
					tmp[i] = this.c_results[i]
				end

				ret[index + 1] = tmp
			end
			return ret
		end
	end

	chdl_array.get_index_bitvec = function(this, index)
		do
			local chosen_hdl = this.array_hdls[index + 1]
			vpiml.vpiml_get_value_multi(chosen_hdl, this.c_results, this.beat_num)

			if this.array_bitvecs[index + 1] then
				this.array_bitvecs[index + 1]:_update_u32_vec(this.c_results)
				return this.array_bitvecs[index + 1]
			else
				this.array_bitvecs[index + 1] = BitVec(this.c_results, this.width)
				return this.array_bitvecs[index + 1]
			end
		end
	end
	chdl_array.set_index = function(this, index, value, force_single_beat)
		local chosen_hdl = this.array_hdls[index + 1]
		do
			if force_single_beat then
				if type(value) == "table" then
					assert(false)
				end
				vpiml.vpiml_set_value64_force_single(chosen_hdl, value)
			else
				--# value is a table where <lsb ... msb>
				if type(value) ~= "table" then
					assert(
						false,
						type(value)
							.. " =/= table \n"
							.. this.name
							.. " is a multibeat hdl, <value> should be a multibeat value which is represented as a <table> in verilua or you can call <CallableHDL>:set(<value>, <force_single_beat>) with <force_single_beat> == true, name => "
							.. this.fullpath
					)
				end

				local beat_num = this.beat_num
				if #value ~= beat_num then
					assert(false, "len: " .. #value .. " =/= " .. this.beat_num)
				end

				if beat_num == 3 then --# 32 * 3 = 96 bits
					vpiml.vpiml_set_value_multi_beat_3(chosen_hdl, value[1], value[2], value[3])
				elseif beat_num == 4 then --# 32 * 4 = 128 bits
					vpiml.vpiml_set_value_multi_beat_4(chosen_hdl, value[1], value[2], value[3], value[4])
				elseif beat_num == 5 then --# 32 * 5 = 160 bits
					vpiml.vpiml_set_value_multi_beat_5(chosen_hdl, value[1], value[2], value[3], value[4], value[5])
				elseif beat_num == 6 then --# 32 * 6 = 192 bits
					vpiml.vpiml_set_value_multi_beat_6(chosen_hdl, value[1], value[2], value[3], value[4], value[5], value[6])
				elseif beat_num == 7 then --# 32 * 7 = 224 bits
					vpiml.vpiml_set_value_multi_beat_7(chosen_hdl, value[1], value[2], value[3], value[4], value[5], value[6], value[7])
				elseif beat_num == 8 then --# 32 * 8 = 256 bits
					vpiml.vpiml_set_value_multi_beat_8(chosen_hdl, value[1], value[2], value[3], value[4], value[5], value[6], value[7], value[8])
				else
					for i = 1, this.beat_num do
						this.c_results[i - 1] = value[i]
					end
					vpiml.vpiml_set_value_multi(chosen_hdl, this.c_results)
				end
			end
		end
	end
	do
		chdl_array.set_index_unsafe = function(this, index, value, force_single_beat)
			local chosen_hdl = this.array_hdls[index + 1]
			if force_single_beat then
				vpiml.vpiml_force_value64_force_single(chosen_hdl, value)
			else
				--# value is a table where <lsb ... msb>
				local beat_num = this.beat_num

				if beat_num == 3 then --# 32 * 3 = 96 bits
					vpiml.vpiml_set_value_multi_beat_3(chosen_hdl, value[1], value[2], value[3])
				elseif beat_num == 4 then --# 32 * 4 = 128 bits
					vpiml.vpiml_set_value_multi_beat_4(chosen_hdl, value[1], value[2], value[3], value[4])
				elseif beat_num == 5 then --# 32 * 5 = 160 bits
					vpiml.vpiml_set_value_multi_beat_5(chosen_hdl, value[1], value[2], value[3], value[4], value[5])
				elseif beat_num == 6 then --# 32 * 6 = 192 bits
					vpiml.vpiml_set_value_multi_beat_6(chosen_hdl, value[1], value[2], value[3], value[4], value[5], value[6])
				elseif beat_num == 7 then --# 32 * 7 = 224 bits
					vpiml.vpiml_set_value_multi_beat_7(chosen_hdl, value[1], value[2], value[3], value[4], value[5], value[6], value[7])
				elseif beat_num == 8 then --# 32 * 8 = 256 bits
					vpiml.vpiml_set_value_multi_beat_8(chosen_hdl, value[1], value[2], value[3], value[4], value[5], value[6], value[7], value[8])
				else
					for i = 1, this.beat_num do
						this.c_results[i - 1] = value[i]
					end
					vpiml.vpiml_set_value_multi(chosen_hdl, this.c_results)
				end
			end
		end
	end

	chdl_array.set_index_bitfield = function(this, index, s, e, v)
		local _ = this.array_hdls[index + 1]
		do
			local bv = this:get_index_bitvec(index):_set_bitfield(s, e, v)
			this:set_index_unsafe(index, bv.u32_vec)
		end
	end

	chdl_array.set_index_bitfield_hex_str = function(this, index, s, e, hex_str)
		local _ = this.array_hdls[index + 1]
		do
			local bv = this:get_index_bitvec(index):_set_bitfield_hex_str(s, e, hex_str)
			this:set_index_unsafe(index, bv.u32_vec)
		end
	end

	chdl_array.set_index_all = function(this, values, force_single_beat)
		force_single_beat = force_single_beat or false
		for index = 0, this.array_size - 1 do
			this:set_index(index, values[index + 1], force_single_beat)
		end
	end

	chdl_array.set_index_unsafe_all = function(this, values, force_single_beat)
		force_single_beat = force_single_beat or false
		for index = 0, this.array_size - 1 do
			this:set_index_unsafe(index, values[index + 1], force_single_beat)
		end
	end
	chdl_array.set_imm_index = function(this, index, value, force_single_beat)
		local chosen_hdl = this.array_hdls[index + 1]
		do
			if force_single_beat then
				if type(value) == "table" then
					assert(false)
				end
				vpiml.vpiml_set_imm_value64_force_single(chosen_hdl, value)
			else
				--# value is a table where <lsb ... msb>
				if type(value) ~= "table" then
					assert(
						false,
						type(value)
							.. " =/= table \n"
							.. this.name
							.. " is a multibeat hdl, <value> should be a multibeat value which is represented as a <table> in verilua or you can call <CallableHDL>:set(<value>, <force_single_beat>) with <force_single_beat> == true, name => "
							.. this.fullpath
					)
				end

				local beat_num = this.beat_num
				if #value ~= beat_num then
					assert(false, "len: " .. #value .. " =/= " .. this.beat_num)
				end

				if beat_num == 3 then --# 32 * 3 = 96 bits
					vpiml.vpiml_set_imm_value_multi_beat_3(chosen_hdl, value[1], value[2], value[3])
				elseif beat_num == 4 then --# 32 * 4 = 128 bits
					vpiml.vpiml_set_imm_value_multi_beat_4(chosen_hdl, value[1], value[2], value[3], value[4])
				elseif beat_num == 5 then --# 32 * 5 = 160 bits
					vpiml.vpiml_set_imm_value_multi_beat_5(chosen_hdl, value[1], value[2], value[3], value[4], value[5])
				elseif beat_num == 6 then --# 32 * 6 = 192 bits
					vpiml.vpiml_set_imm_value_multi_beat_6(chosen_hdl, value[1], value[2], value[3], value[4], value[5], value[6])
				elseif beat_num == 7 then --# 32 * 7 = 224 bits
					vpiml.vpiml_set_imm_value_multi_beat_7(chosen_hdl, value[1], value[2], value[3], value[4], value[5], value[6], value[7])
				elseif beat_num == 8 then --# 32 * 8 = 256 bits
					vpiml.vpiml_set_imm_value_multi_beat_8(chosen_hdl, value[1], value[2], value[3], value[4], value[5], value[6], value[7], value[8])
				else
					for i = 1, this.beat_num do
						this.c_results[i - 1] = value[i]
					end
					vpiml.vpiml_set_imm_value_multi(chosen_hdl, this.c_results)
				end
			end
		end
	end
	do
		chdl_array.set_imm_index_unsafe = function(this, index, value, force_single_beat)
			local chosen_hdl = this.array_hdls[index + 1]
			if force_single_beat then
				vpiml.vpiml_force_imm_value64_force_single(chosen_hdl, value)
			else
				--# value is a table where <lsb ... msb>
				local beat_num = this.beat_num

				if beat_num == 3 then --# 32 * 3 = 96 bits
					vpiml.vpiml_set_imm_value_multi_beat_3(chosen_hdl, value[1], value[2], value[3])
				elseif beat_num == 4 then --# 32 * 4 = 128 bits
					vpiml.vpiml_set_imm_value_multi_beat_4(chosen_hdl, value[1], value[2], value[3], value[4])
				elseif beat_num == 5 then --# 32 * 5 = 160 bits
					vpiml.vpiml_set_imm_value_multi_beat_5(chosen_hdl, value[1], value[2], value[3], value[4], value[5])
				elseif beat_num == 6 then --# 32 * 6 = 192 bits
					vpiml.vpiml_set_imm_value_multi_beat_6(chosen_hdl, value[1], value[2], value[3], value[4], value[5], value[6])
				elseif beat_num == 7 then --# 32 * 7 = 224 bits
					vpiml.vpiml_set_imm_value_multi_beat_7(chosen_hdl, value[1], value[2], value[3], value[4], value[5], value[6], value[7])
				elseif beat_num == 8 then --# 32 * 8 = 256 bits
					vpiml.vpiml_set_imm_value_multi_beat_8(chosen_hdl, value[1], value[2], value[3], value[4], value[5], value[6], value[7], value[8])
				else
					for i = 1, this.beat_num do
						this.c_results[i - 1] = value[i]
					end
					vpiml.vpiml_set_imm_value_multi(chosen_hdl, this.c_results)
				end
			end
		end
	end

	chdl_array.set_imm_index_bitfield = function(this, index, s, e, v)
		local _ = this.array_hdls[index + 1]
		do
			local bv = this:get_index_bitvec(index):_set_bitfield(s, e, v)
			this:set_imm_index_unsafe(index, bv.u32_vec)
		end
	end

	chdl_array.set_imm_index_bitfield_hex_str = function(this, index, s, e, hex_str)
		local _ = this.array_hdls[index + 1]
		do
			local bv = this:get_index_bitvec(index):_set_bitfield_hex_str(s, e, hex_str)
			this:set_index_unsafe(index, bv.u32_vec)
		end
	end

	chdl_array.set_imm_index_all = function(this, values, force_single_beat)
		force_single_beat = force_single_beat or false
		for index = 0, this.array_size - 1 do
			this:set_imm_index(index, values[index + 1], force_single_beat)
		end
	end

	chdl_array.set_imm_index_unsafe_all = function(this, values, force_single_beat)
		force_single_beat = force_single_beat or false
		for index = 0, this.array_size - 1 do
			this:set_imm_index_unsafe(index, values[index + 1], force_single_beat)
		end
	end
end

return function(is_array)
	chdl_init()

	if is_array then
		chdl_array_init()
		for k, func in pairs(chdl_array) do
			chdl[k] = func
		end
	end

	return chdl
end
