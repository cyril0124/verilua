----------------------------------------------------
-- Auto generated by gen_scheduler.lua
-- DO NOT edit this file!
----------------------------------------------------

--[[luajit-pro, {NORMAL = 0, EDGE_STEP = 1, STEP = 0, ACC_TIME = 0, SAFETY = 0}]] 





















local math = require "math"
local debug = require "debug"
require "vpiml"
local class = require "pl.class"
local coroutine = require "coroutine"
local table_clear = require "table.clear"

local f = string.format
local random = math.random
local table_remove = table.remove
local table_insert = table.insert
local coro_yield = coroutine.yield
local coro_resume = coroutine.resume
local coro_create = coroutine.create







local Timer = 0
local Posedge = 1
local PosedgeHDL = 2
local Negedge = 3
local NegedgeHDL = 4

local PosedgeAlwaysHDL = 6

local NegedgeAlwaysHDL = 8


local EarlyExit = 11
local Event = 12
local NOOP = 44

---@class (exact) verilua.LuaScheduler_gen_LuaEdgeStepSchedulerV2
---@field private running_task_count integer Number of running tasks
---@field private task_yield_info_map table<TaskID, CoroutineYieldInfo> Map of task IDs to coroutine yield info
---@field private task_coroutine_map table<TaskID, thread> Map of task IDs to coroutine threads
---@field private task_body_map table<TaskID, CoroutineTaskBody> Map of task IDs to coroutine task bodies
---@field private task_name_map_running table<TaskID, string> Map of running task IDs to task names
---@field private task_name_map_archived table<TaskID, string> Map of archived task IDs to task names
---@field private task_fired_status_map table<TaskID, boolean> Map of task IDs to their fired status
---@field private task_execution_count_map table<TaskID, integer> Map of task IDs to their execution count
---@field private pending_removal_tasks TaskID[] List of task IDs pending removal
---@field private user_removal_tasks TaskID[] List of user specified task IDs to be removed
---@field private posedge_tasks table<TaskID, boolean> Available only when EDGE_STEP is enabled)
---@field private negedge_tasks table<TaskID, boolean> Available only when EDGE_STEP is enabled)
---@field event_task_id_list_map table<EventID, TaskID[]> Map of event IDs to lists of task IDs
---@field event_name_map table<EventID, string> Map of event IDs to event names
---@field private has_wakeup_event boolean Indicates if there is a wakeup event
---@field private pending_wakeup_event table<EventID, any> List of pending wakeup event IDs
---@field private acc_time_table table<string, number> Accumulated time table
---@field private _is_coroutine_task fun(self: verilua.LuaScheduler_gen_LuaEdgeStepSchedulerV2, task_id: TaskID): boolean Checks if a task is a coroutine task
---@field private _alloc_coroutine_task_id fun(self: verilua.LuaScheduler_gen_LuaEdgeStepSchedulerV2): TaskID Allocates a new coroutine task ID
---@field private _remove_task fun(self: verilua.LuaScheduler_gen_LuaEdgeStepSchedulerV2, task_id: TaskID) Removes a task by ID
---@field private _register_callback fun(self: verilua.LuaScheduler_gen_LuaEdgeStepSchedulerV2, task_id: TaskID, callback_type: TaskCallbackType, str_value: string, integer_value: integer) Registers a callback for a task
---@field curr_task_id TaskID Current task ID
---@field curr_wakeup_event_id EventID Current wakeup event ID
---@field private new_event_hdl fun(self: verilua.LuaScheduler_gen_LuaEdgeStepSchedulerV2, event_name: string, user_event_id?: EventID): EventHandle Creates a new event handle
---@field private get_event_hdl fun(self: verilua.LuaScheduler_gen_LuaEdgeStepSchedulerV2, event_name: string, user_event_id?: EventID): EventHandle Alias for new_event_hdl
---@field private send_event fun(self: verilua.LuaScheduler_gen_LuaEdgeStepSchedulerV2, event_id: EventID) Sends an event
---@field remove_task fun(self: verilua.LuaScheduler_gen_LuaEdgeStepSchedulerV2, task_id: TaskID) Removes a task by ID
---@field check_task_exists fun(self: verilua.LuaScheduler_gen_LuaEdgeStepSchedulerV2, task_id: TaskID): boolean Checks if a task exists
---@field append_task fun(self: verilua.LuaScheduler_gen_LuaEdgeStepSchedulerV2, task_id?: TaskID, task_name: string, task_body: CoroutineTaskBody, start_now?: boolean): TaskID Appends or registers a new task
---@field wakeup_task fun(self: verilua.LuaScheduler_gen_LuaEdgeStepSchedulerV2, task_id: TaskID) Wakes up a registered task
---@field try_wakeup_task fun(self: verilua.LuaScheduler_gen_LuaEdgeStepSchedulerV2, task_id: TaskID) Tries to wake up a registered task, does nothing if the task is still running
---@field schedule_task fun(self: verilua.LuaScheduler_gen_LuaEdgeStepSchedulerV2, task_id: TaskID) Schedules a specific task
---@field schedule_tasks fun(self: verilua.LuaScheduler_gen_LuaEdgeStepSchedulerV2, task_id: TaskID) Schedules multiple tasks
---@field schedule_all_tasks fun(self: verilua.LuaScheduler_gen_LuaEdgeStepSchedulerV2) Schedules all tasks
---@field schedule_posedge_tasks fun(self: verilua.LuaScheduler_gen_LuaEdgeStepSchedulerV2)|nil Schedules positive edge tasks (available only when EDGE_STEP is enabled)
---@field schedule_negedge_tasks fun(self: verilua.LuaScheduler_gen_LuaEdgeStepSchedulerV2)|nil Schedules negative edge tasks (available only when EDGE_STEP is enabled)
---@field list_tasks fun(self: verilua.LuaScheduler_gen_LuaEdgeStepSchedulerV2) Lists all running tasks
local Scheduler = class()

-- TaskID from 0 to 99999 is reserved for coroutine task
local SCHEDULER_TASK_ID_MIN_COROUTINE = 0
local SCHEDULER_TASK_ID_MAX_COROUTINE = 0xFFFFFFF

local SCHEDULER_MAX_RUNNING_TASK_COUNT = 100000
local SCHEDULER_MIN_EVENT_ID = 0
local SCHEDULER_MAX_EVENT_ID = 0xFFFFFFF

local SCHEDULER_ALLOC_TASK_ID_MAX_CNT = 0xFFFFFFF
local SCHEDULER_ALLOC_EVENT_ID_MAX_CNT = 0xFFFFFFF

function Scheduler:_init()
    self.running_task_count = 0

    self.task_coroutine_map = {}
    self.task_body_map = {}
    self.task_name_map_running = {}
    self.task_name_map_archived = {}
    self.task_fired_status_map = {} -- Used to check if a task has been fired
    self.task_execution_count_map = {}
    self.pending_removal_tasks = {}
    self.user_removal_tasks = {}
do        


self.posedge_tasks = {}
        self.negedge_tasks = {}
end
    
self.event_task_id_list_map = {}
    self.event_name_map = {}
    self.has_wakeup_event = false
    self.pending_wakeup_event = {}













end

function Scheduler:_is_coroutine_task(id)
    return id <= SCHEDULER_TASK_ID_MAX_COROUTINE and id >= SCHEDULER_TASK_ID_MIN_COROUTINE
end

function Scheduler:check_task_exists(id)
    return self.task_name_map_running[id] ~= nil
end

function Scheduler:_alloc_coroutine_task_id()
    local id = random(SCHEDULER_TASK_ID_MIN_COROUTINE, SCHEDULER_TASK_ID_MAX_COROUTINE)
    local cnt = 0
    while self.task_name_map_archived[id] ~= nil do
        id = random(SCHEDULER_TASK_ID_MIN_COROUTINE, SCHEDULER_TASK_ID_MAX_COROUTINE)
        cnt = cnt + 1
        if cnt >= SCHEDULER_ALLOC_TASK_ID_MAX_CNT then
            assert(
                false,
                "[Scheduler] Failed to allocate coroutine task id! too many attempts, maybe there are no available task id"
            )
        end
    end
    return id
end

function Scheduler:_remove_task(id)
    self.running_task_count = self.running_task_count - 1
    table_insert(self.pending_removal_tasks, id)
do        


if self.posedge_tasks[id] then
            self.posedge_tasks[id] = nil
        elseif self.negedge_tasks[id] then
            self.negedge_tasks[id] = nil
        end
end
end

function Scheduler:remove_task(id)
    if not self.task_name_map_archived[id] then
        assert(false, "[Scheduler] Invalid task id! task_id: " .. id)
    end

    if self.task_name_map_running[id] ~= nil then
        table_insert(self.user_removal_tasks, id)
    end
end

function Scheduler:_register_callback(id, cb_type, str_value, integer_value)
do        
































if cb_type == PosedgeHDL or cb_type == Posedge or cb_type == PosedgeAlwaysHDL or cb_type == Timer then
            self.posedge_tasks[id] = true
        elseif cb_type == NegedgeHDL or cb_type == Negedge or cb_type == NegedgeAlwaysHDL then
            self.negedge_tasks[id] = true
        elseif cb_type == NOOP then
            -- do nothing
        elseif cb_type == Event then
            if self.event_name_map[integer_value] == nil then
                assert(false, "Unknown event => " .. integer_value)
            end
            table_insert(self.event_task_id_list_map[integer_value], id)
        else
            assert(false, "Unknown YieldType => " .. tostring(cb_type))
        end
end
end

-- Used for creating a new coroutine task
function Scheduler:append_task(id, name, task_body, start_now)
do        




assert(self.running_task_count <= SCHEDULER_MAX_RUNNING_TASK_COUNT, "[Step Scheduler] Too many tasks!")
end
    
























local task_id = id
    if id then
        if not self:_is_coroutine_task(id) then
            assert(false, "[Scheduler] Invalid coroutine task id!")
        end

        if self:check_task_exists(id) then
            local task_name = self.task_name_map_running[id]
            assert(false, "[Scheduler] Task already exists! task_id: " .. id .. ", task_name: " .. task_name)
        end
    else
        task_id = self:_alloc_coroutine_task_id()
    end
    ---@cast task_id TaskID

    self.task_name_map_running[task_id] = name
    self.task_name_map_archived[task_id] = name
    self.task_fired_status_map[task_id] = false
    self.task_coroutine_map[task_id] = coro_create(task_body)
    self.task_body_map[task_id] = task_body
    self.task_execution_count_map[task_id] = 0

    self.running_task_count = self.running_task_count + 1
do        

if start_now then
            self.task_fired_status_map[task_id] = true
            self:schedule_task(task_id)
        end
end
    
return task_id
end

function Scheduler:wakeup_task(id)
    local task_name = self.task_name_map_archived[id]
    if task_name == nil then
        assert(false, "[Scheduler] Task not registered! task_id: " .. id)
    end

    if self.task_name_map_running[id] ~= nil then
        assert(false, "[Scheduler] Task already running! task_id: " .. id .. ", task_name: " .. task_name)
    end

    self.task_name_map_running[id] = task_name
    self.task_fired_status_map[id] = true
    self.task_coroutine_map[id] = coro_create(self.task_body_map[id])
    self:schedule_task(id)
end

function Scheduler:try_wakeup_task(id)
    if self:check_task_exists(id) then
        return
    else
        local task_name = self.task_name_map_archived[id]
        if task_name == nil then
            assert(false, "[Scheduler] Task not registered! task_id: " .. id)
        end

        self.task_name_map_running[id] = task_name
        self.task_fired_status_map[id] = true
        self.task_coroutine_map[id] = coro_create(self.task_body_map[id])
        self:schedule_task(id)
    end
end

function Scheduler:schedule_task(id)
    for _, remove_id in ipairs(self.pending_removal_tasks) do
        self.task_name_map_running[remove_id] = nil
        self.task_execution_count_map[remove_id] = 0
        self.task_fired_status_map[remove_id] = false
    





end
    table_clear(self.pending_removal_tasks)

    for i, remove_id in ipairs(self.user_removal_tasks) do
        if remove_id == id then
            table_remove(self.user_removal_tasks, i)
            self.task_name_map_running[remove_id] = nil
            self.task_execution_count_map[remove_id] = 0
            self.task_fired_status_map[remove_id] = false
            return
        end
    end

    local task_cnt = self.task_execution_count_map[id]
    self.task_execution_count_map[id] = task_cnt + 1

    




local old_curr_task_id                       = self.curr_task_id
    self.curr_task_id                            = id

    local ok, cb_type_or_err, str_value, integer_value
    ok, cb_type_or_err, str_value, integer_value = coro_resume(self.task_coroutine_map[id])

    ---@cast ok boolean
    ---@cast cb_type_or_err TaskCallbackType
    ---@cast str_value string
    ---@cast integer_value integer

    self.curr_task_id                            = old_curr_task_id
    if not ok then
        print(f(
            "[Scheduler] Error while executing task(id: %d, name: %s)\n\t%s",
            id,
            self.task_name_map_running[id],
            debug.traceback(self.task_coroutine_map[id], cb_type_or_err)
        ))
        io.flush()

        _G.VERILUA_GOT_ERROR = true
        assert(false)
    end

    if cb_type_or_err == nil or cb_type_or_err == EarlyExit then
        self:_remove_task(id)
    else
        self:_register_callback(id, cb_type_or_err, str_value, integer_value)
    end

    













if self.has_wakeup_event then
        self.has_wakeup_event = false
        for _, event_id in ipairs(self.pending_wakeup_event) do
            self.curr_wakeup_event_id = event_id
            local wakeup_task_id_list = self.event_task_id_list_map[event_id]
            for _, wakeup_task_id in ipairs(wakeup_task_id_list) do
                self:schedule_task(wakeup_task_id)
            end
            self.curr_wakeup_event_id = nil
            table_clear(self.event_task_id_list_map[event_id])
        end
        table_clear(self.pending_wakeup_event)
    end
end

function Scheduler:schedule_tasks(id)
    self:schedule_task(id)
end

function Scheduler:schedule_all_tasks()
    for id, _ in pairs(self.task_name_map_running) do
do            






self:schedule_task(id)
end    
end
end

function Scheduler:schedule_posedge_tasks()
do        
for id, _ in pairs(self.posedge_tasks) do
            self:schedule_task(id)
        end
end


end

function Scheduler:schedule_negedge_tasks()
do        
for id, _ in pairs(self.negedge_tasks) do
            self:schedule_task(id)
        end
end


end

function Scheduler:list_tasks()
    print("╔══════════════════════════════════════════════════════════════════════")
    print("║ [Scheduler] List Tasks:")
    print("╠══════════════════════════════════════════════════════════════════════")

    













































































local max_name_str_len = 0 --[[@as integer]]
    for _, name in pairs(self.task_name_map_running) do
        local len = #name
        if len > max_name_str_len then
            max_name_str_len = len
        end
    end

    local idx = 0
    for id, name in pairs(self.task_name_map_running) do
        print(f("║ [%2d] name: %" .. max_name_str_len .. "s    id: %5d    cnt:%8d", idx, name, id,
            self.task_execution_count_map[id]))
        idx = idx + 1
    end
    print("╚══════════════════════════════════════════════════════════════════════")
    print()
end

function Scheduler:send_event(event_id)
    table_insert(self.pending_wakeup_event, event_id)
    self.has_wakeup_event = true
end

--
-- Example:
--      local scheduler = require "verilua.scheduler.LuaScheduler"
--      local test_ehdl = scheduler:new_event_hdl("test_1") -- event id will be randomly allocated
--      test_ehdl:wait()
--      test_ehdl:send()
--
--      local test_ehdl = scheduler:new_event_hdl("test_1", 1) -- manually set event_id
--
--      local test_ehdl = scheduler:new_event_hdl "test_1"
--
--
function Scheduler:new_event_hdl(name, user_event_id)

    


local event_id = user_event_id
    if not event_id then
        event_id = random(SCHEDULER_MIN_EVENT_ID, SCHEDULER_MAX_EVENT_ID)
        local cnt = 0
        while self.event_name_map[event_id] do
            event_id = random(SCHEDULER_MIN_EVENT_ID, SCHEDULER_MAX_EVENT_ID)
            cnt = cnt + 1
            if cnt >= SCHEDULER_ALLOC_EVENT_ID_MAX_CNT then
                assert(false,
                    "[Scheduler] Failed to allocate event id! too many attempts, maybe there are no available event id")
            end
        end
    else
        assert(
            type(user_event_id) == "number" and user_event_id == math.floor(user_event_id),
            "user_event_id must be an integer"
        )
    end

    ---@cast event_id EventID

    self.event_name_map[event_id] = name
    self.event_task_id_list_map[event_id] = {} -- task id comes from register_callback => (cb_type == Event)

    ---@type EventHandle
    local ehdl = {
        __type = "EventHandle",
        _scheduler = self --[[@as verilua.LuaScheduler]],
        name = name,
        event_id = event_id,
        has_pending_wait = function(this)
            return #self.event_task_id_list_map[this.event_id] > 0
        end,
        wait = function(this)
            coro_yield(Event, "", this.event_id)
        end,
        send = function(this)
            this._scheduler:send_event(this.event_id)
        end,
        remove = function(this)
            this._scheduler.event_name_map[this.event_id] = nil
        end
    }
    return ehdl
end

function Scheduler:get_event_hdl(name, user_event_id)
    return self:new_event_hdl(name, user_event_id)
end

return Scheduler()
