----------------------------------------------------
-- Auto generated by gen_scheduler.tl
-- DO NOT edit this file!
----------------------------------------------------

 local _tl_compat
if (tonumber((_VERSION or ""):match("[%d.]*$")) or 0) < 5.3 then
	local p, m = pcall(require, "compat53.module")
	if p then
		_tl_compat = m
	end
end
local assert = _tl_compat and _tl_compat.assert or assert
local _ = _tl_compat and _tl_compat.coroutine or coroutine
local _ = _tl_compat and _tl_compat.debug or debug
local io = _tl_compat and _tl_compat.io or io
local ipairs = _tl_compat and _tl_compat.ipairs or ipairs
local _ = _tl_compat and _tl_compat.math or math
local os = _tl_compat and _tl_compat.os or os
local pairs = _tl_compat and _tl_compat.pairs or pairs
local string = _tl_compat and _tl_compat.string or string
local table = _tl_compat and _tl_compat.table or table
local type = type

local math = require("math")
local debug = require("debug")
require("vpiml")
local class = require("pl.class")
local coroutine = require("coroutine")
local table_clear = require("table.clear")

local f = string.format
local random = math.random
local table_remove = table.remove
local table_insert = table.insert
local coro_yield = coroutine.yield
local coro_resume = coroutine.resume
local coro_create = coroutine.create

local os_clock
do
	os_clock = os.clock
end

local EarlyExit = 11
local Event = 12

local Scheduler = class()

local SCHEDULER_TASK_ID_MIN_COROUTINE = 0
local SCHEDULER_TASK_ID_MAX_COROUTINE = 99999

local SCHEDULER_TASK_ID_MIN_FUNCTION = 100000
local SCHEDULER_TASK_ID_MAX_FUNCTION = 199999

local SCHEDULER_TASK_MAX_COUNT = 100000
local SCHEDULER_MIN_EVENT_ID = 0
local SCHEDULER_MAX_EVENT_ID = 999

local SCHEDULER_ALLOC_TASK_ID_MAX_CNT = 99999
local SCHEDULER_ALLOC_EVENT_ID_MAX_CNT = 999

function Scheduler:_init()
	self.task_count = 0

	self.task_coroutine_map = {}
	self.task_body_map = {}
	self.task_name_map_running = {}
	self.task_name_map_archived = {}
	self.task_fired_status_map = {}
	self.task_execution_count_map = {}
	self.pending_removal_tasks = {}
	self.user_removal_tasks = {}
	do
		self.posedge_tasks = {}
		self.negedge_tasks = {}
	end

	self.event_task_id_list_map = {}
	self.event_name_map = {}
	self.has_wakeup_event = false
	self.pending_wakeup_event = {}
	do
		self.acc_time_table = {}
	end
	do
		verilua_debug("[Scheduler]", "Using STEP scheduler")
	end
end

function Scheduler:_is_coroutine_task(id)
	return id <= SCHEDULER_TASK_ID_MAX_COROUTINE and id >= SCHEDULER_TASK_ID_MIN_COROUTINE
end

function Scheduler:check_task_exists(id)
	return self.task_name_map_running[id] ~= nil
end

function Scheduler:_alloc_coroutine_task_id()
	local id = random(SCHEDULER_TASK_ID_MIN_COROUTINE, SCHEDULER_TASK_ID_MAX_COROUTINE)
	local cnt = 0
	while self.task_name_map_archived[id] ~= nil do
		id = random(SCHEDULER_TASK_ID_MIN_COROUTINE, SCHEDULER_TASK_ID_MAX_COROUTINE)
		cnt = cnt + 1
		if cnt >= SCHEDULER_ALLOC_TASK_ID_MAX_CNT then
			assert(false, "[Scheduler] Failed to allocate coroutine task id! too many attempts, maybe there are no available task id")
		end
	end
	return id
end

function Scheduler:_alloc_function_task_id()
	local id = random(SCHEDULER_TASK_ID_MIN_FUNCTION, SCHEDULER_TASK_ID_MAX_FUNCTION)
	local cnt = 0
	while self.task_name_map_archived[id] ~= nil do
		id = random(SCHEDULER_TASK_ID_MIN_FUNCTION, SCHEDULER_TASK_ID_MAX_FUNCTION)
		cnt = cnt + 1
		if cnt >= SCHEDULER_ALLOC_TASK_ID_MAX_CNT then
			assert(false, "[Scheduler] Failed to allocate function task id! too many attempts, maybe there are no available task id")
		end
	end
	return id
end

function Scheduler:_remove_task(id)
	self.task_count = self.task_count - 1
	table_insert(self.pending_removal_tasks, id)
	do
		if self.posedge_tasks[id] then
			self.posedge_tasks[id] = nil
		elseif self.negedge_tasks[id] then
			self.negedge_tasks[id] = nil
		end
	end
end

function Scheduler:remove_task(id)
	if not self.task_name_map_archived[id] then
		assert(false, "[Scheduler] Invalid task id! task_id: " .. id)
	end

	if self.task_name_map_running[id] then
		table_insert(self.user_removal_tasks, id)
	end
end

function Scheduler:_register_callback(id, cb_type, str_value, integer_value)
	do
		if cb_type == Event then
			if self.event_name_map[integer_value] == nil then
				assert(false, "Unknown event => " .. integer_value)
			end
			table_insert(self.event_task_id_list_map[integer_value], id)
		end
	end
end

function Scheduler:append_task(id, name, task_body, start_now)
	do
		assert(self.task_count <= SCHEDULER_TASK_MAX_COUNT, "[Step Scheduler] Too many tasks!")
	end

	local task_id = id
	if id then
		if not self:_is_coroutine_task(id) then
			assert(false, "[Scheduler] Invalid coroutine task id!")
		end

		if self:check_task_exists(id) then
			local task_name = self.task_name_map_running[id]
			assert(false, "[Scheduler] Task already exists! task_id: " .. id .. ", task_name: " .. task_name)
		end
	else
		task_id = self:_alloc_coroutine_task_id()
	end

	self.task_name_map_running[task_id] = name
	self.task_name_map_archived[task_id] = name
	self.task_fired_status_map[task_id] = false
	self.task_coroutine_map[task_id] = coro_create(task_body)
	self.task_body_map[task_id] = task_body
	self.task_execution_count_map[task_id] = 0

	self.task_count = self.task_count + 1
	do
		if start_now then
			self.task_fired_status_map[task_id] = true
			self:schedule_task(task_id)
		end
	end

	return task_id
end

function Scheduler:wakeup_task(id)
	local task_name = self.task_name_map_archived[id]
	if task_name == nil then
		assert(false, "[Scheduler] Task not registered! task_id: " .. id)
	end

	if self.task_name_map_running[id] then
		assert(false, "[Scheduler] Task already running! task_id: " .. id .. ", task_name: " .. task_name)
	end

	self.task_name_map_running[id] = task_name
	self.task_fired_status_map[id] = true
	self.task_coroutine_map[id] = coro_create(self.task_body_map[id])
	self:schedule_task(id)
end

function Scheduler:try_wakeup_task(id)
	if self:check_task_exists(id) then
		return
	else
		local task_name = self.task_name_map_archived[id]
		if task_name == nil then
			assert(false, "[Scheduler] Task not registered! task_id: " .. id)
		end

		self.task_name_map_running[id] = task_name
		self.task_fired_status_map[id] = true
		self.task_coroutine_map[id] = coro_create(self.task_body_map[id])
		self:schedule_task(id)
	end
end

function Scheduler:schedule_task(id)
	for _, remove_id in ipairs(self.pending_removal_tasks) do
		self.task_name_map_running[remove_id] = nil
		self.task_execution_count_map[remove_id] = 0
		self.task_fired_status_map[remove_id] = false
	end
	table_clear(self.pending_removal_tasks)

	for i, remove_id in ipairs(self.user_removal_tasks) do
		if remove_id == id then
			table_remove(self.user_removal_tasks, i)
			self.task_name_map_running[remove_id] = nil
			self.task_execution_count_map[remove_id] = 0
			self.task_fired_status_map[remove_id] = false
			return
		end
	end

	local task_cnt = self.task_execution_count_map[id]
	self.task_execution_count_map[id] = task_cnt + 1

	local s, e
	do
		s = os_clock()
	end

	local ok, cb_type_or_err, str_value, integer_value
	do
		ok, cb_type_or_err, str_value, integer_value = coro_resume(self.task_coroutine_map[id])

		if not ok then
			print(f("[Scheduler] Error while executing task(id: %d, name: %s)\n\t%s", id, self.task_name_map_running[id], debug.traceback(self.task_coroutine_map[id], cb_type_or_err)))
			io.flush()

			_G.verilua_get_error = true
			assert(false)
		end
	end

	if cb_type_or_err == nil or cb_type_or_err == EarlyExit then
		self:_remove_task(id)
	else
		self:_register_callback(id, cb_type_or_err, str_value, integer_value)
	end
	do
		e = os_clock()
		local name = self.task_name_map_running[id]

		local key = tostring(id) .. "@" .. name
		self.acc_time_table[key] = (self.acc_time_table[key] or 0) + (e - s)
	end

	if self.has_wakeup_event then
		self.has_wakeup_event = false
		for _, event_id in ipairs(self.pending_wakeup_event) do
			local wakeup_task_id_list = self.event_task_id_list_map[event_id]
			for _, wakeup_task_id in ipairs(wakeup_task_id_list) do
				self:schedule_task(wakeup_task_id)
			end
			table_clear(self.event_task_id_list_map[event_id])
		end
		table_clear(self.pending_wakeup_event)
	end
end

function Scheduler:schedule_tasks(id)
	self:schedule_task(id)
end

function Scheduler:schedule_all_tasks()
	for id, _ in pairs(self.task_name_map_running) do
		do
			self:schedule_task(id)
		end
	end
end

function Scheduler:schedule_posedge_tasks()
	do
		for id, _ in pairs(self.posedge_tasks) do
			self:schedule_task(id)
		end
	end
end

function Scheduler:schedule_negedge_tasks()
	do
		for id, _ in pairs(self.negedge_tasks) do
			self:schedule_task(id)
		end
	end
end

function Scheduler:list_tasks()
	print("╔══════════════════════════════════════════════════════════════════════")
	print("║ [Scheduler] List Tasks:")
	print("╠══════════════════════════════════════════════════════════════════════")
	do
		local total_time = 0
		local max_key_str_len = 0

		local task_name_count = {}
		for key, _time in pairs(self.acc_time_table) do
			local _task_id, task_name = key:match("([^@]+)@(.*)")
			task_name_count[task_name] = (task_name_count[task_name] or 0) + 1
		end

		local filtered_acc_time_table = {}
		for key, time in pairs(self.acc_time_table) do
			local _task_id, task_name = key:match("([^@]+)@(.*)")
			if task_name_count[task_name] >= 20 then
				key = f("<...>@%s", task_name)
				filtered_acc_time_table[key] = (filtered_acc_time_table[key] or 0) + time
			else
				filtered_acc_time_table[key] = time
			end

			total_time = total_time + time

			local len = #key
			if len > max_key_str_len then
				max_key_str_len = len
			end
		end
		self.acc_time_table = filtered_acc_time_table

		local sorted_keys = {}
		for key, _ in pairs(filtered_acc_time_table) do
			table.insert(sorted_keys, key)
		end
		table.sort(sorted_keys, function(a, b)
			return filtered_acc_time_table[a] < filtered_acc_time_table[b]
		end)

		local max_str_len = 0
		local print_str_vec = {}
		for _, key in ipairs(sorted_keys) do
			local time = self.acc_time_table[key]
			local percent = time / total_time * 100
			local s = f("║ [%" .. max_key_str_len .. "s]   %5.2f ms   percent: %5.2f%%", key, time * 1000, percent)
			local len = #s
			table_insert(print_str_vec, s)

			if len > max_str_len then
				max_str_len = len
			end
		end

		local get_progress_bar = function(progress, length)
			local completed = math.floor(progress * length)
			local remaining = length - completed
			local progressBar = "┃" .. string.rep("█", completed) .. "" .. string.rep("▒", remaining) .. "┃"
			return progressBar
		end

		local idx = 1
		for _, key in ipairs(sorted_keys) do
			local time = self.acc_time_table[key]
			local str = print_str_vec[idx]
			str = str .. string.rep(" ", max_str_len - #str)

			print(f("%-" .. max_str_len .. "s ", str) .. get_progress_bar(time / total_time, 30))
			idx = idx + 1
		end

		print(f("║ total_time: %.2f s / %.2f ms", total_time, total_time * 1000))
		print("╠══════════════════════════════════════════════════════════════════════")
	end

	local max_name_str_len = 0
	for _, name in pairs(self.task_name_map_running) do
		local len = #name
		if len > max_name_str_len then
			max_name_str_len = len
		end
	end

	local idx = 0
	for id, name in pairs(self.task_name_map_running) do
		print(f("║ [%2d] name: %" .. max_name_str_len .. "s    id: %5d    cnt:%8d", idx, name, id, self.task_execution_count_map[id]))
		idx = idx + 1
	end
	print("╚══════════════════════════════════════════════════════════════════════")
	print()
end

function Scheduler:send_event(event_id)
	table_insert(self.pending_wakeup_event, event_id)
	self.has_wakeup_event = true
end

function Scheduler:new_event_hdl(name, user_event_id)
	local event_id = user_event_id
	if not event_id then
		event_id = random(SCHEDULER_MIN_EVENT_ID, SCHEDULER_MAX_EVENT_ID)
		local cnt = 0
		while self.event_name_map[event_id] do
			event_id = random(SCHEDULER_MIN_EVENT_ID, SCHEDULER_MAX_EVENT_ID)
			cnt = cnt + 1
			if cnt >= SCHEDULER_ALLOC_EVENT_ID_MAX_CNT then
				assert(false, "[Scheduler] Failed to allocate event id! too many attempts, maybe there are no available event id")
			end
		end
	else
		assert(type(user_event_id) == "number" and user_event_id == math.floor(user_event_id), "user_event_id must be an integer")
	end

	self.event_name_map[event_id] = name
	self.event_task_id_list_map[event_id] = {}

	return {
		_scheduler = self,
		name = name,
		event_id = event_id,
		has_pending_wait = function(this)
			return #self.event_task_id_list_map[this.event_id] > 0
		end,
		wait = function(this)
			coro_yield(Event, "", this.event_id)
		end,
		send = function(this)
			this._scheduler:send_event(this.event_id)
		end,
	}
end

function Scheduler:get_event_hdl(name, user_event_id)
	return self:new_event_hdl(name, user_event_id)
end

return Scheduler()
