-- jit.opt.start(3)
-- jit.opt.start("loopunroll=100", "minstitch=0", "hotloop=1", "tryside=100")

local os = require "os"
local io = require "io"
local math = require "math"
local debug = require "debug"
local string = require "string"

local type = type
local print = print
local table = table
local pairs = pairs
local pcall = pcall
local ipairs = ipairs
local assert = assert
local f = string.format
local tonumber = tonumber
local tostring = tostring
local math_random = math.random
local getmetatable = getmetatable

-- 
-- strict lua, any undeclared global variables will lead to failed
-- 
require "strict"

_G.inspect = require "inspect"

--- Print any object using `inspect.lua`
---@type fun(...: any)
_G.dbg     = function (...) print(inspect(...)) end
_G.pp      = _G.dbg -- Alias for dbg
_G.dump    = _G.pp -- Alias for dbg
_G.printf  = function (s, ...) io.write(f(s, ...)) end

-- Convert to hex for pretty printing
local convert_to_hex = function(item, path)
    if path[#path] ~= inspect.KEY and (type(item) == "number" or ffi.istype("uint64_t", item)) then
        return bit.tohex(item)
    end
    return item
end

--- Print any object using `inspect.lua` with hex conversion on `number` and `uint64_t`
---@type fun(...: any)
_G.pph = function (...)
    print(inspect(..., {process = convert_to_hex}))
end

-- 
-- #define vpiBinStrVal          1
-- #define vpiOctStrVal          2
-- #define vpiDecStrVal          3
-- #define vpiHexStrVal          4
-- 
_G.BinStr = 1
_G.OctStr = 2
_G.DecStr = 3
_G.HexStr = 4

do
    local PWD = os.getenv("PWD")
    local PRJ_TOP = os.getenv("PRJ_TOP")

    local function append_package_path(path)
        _G.package.path = _G.package.path .. ";" .. path
    end

    if PWD ~= nil then
        append_package_path(PWD .. "/?.lua")
        append_package_path(PWD .. "/src/?.lua")
        append_package_path(PWD .. "/src/lua/?.lua")
    end

    if PRJ_TOP ~= nil then
        append_package_path(PRJ_TOP .. "/?.lua")
        append_package_path(PRJ_TOP .. "/src/?.lua")
        append_package_path(PRJ_TOP .. "/src/lua/?.lua")
    end
end

-- 
-- debug info
-- 
_G.get_debug_info = function (level)
    local info = debug.getinfo(level or 2, "nSl") -- Level 2 because we're inside a function
    
    local file = info.short_src -- info.source
    local line = info.currentline
    local func = info.name or "<anonymous>"

    return file, line, func
end

_G.default_debug_level = 4
_G.debug_level = _G.default_debug_level
_G.debug_str = function(...)
    local file, line, func = _G.get_debug_info(_G.debug_level)
    local args = {...}
    local message = table.concat(args, "\t")
    return (("[%s:%s:%d]"):format(file, func, line) .. "\t" .. message)
end

-- 
-- global debug log functions
-- 
local enable_verilua_debug = os.getenv("VL_DEBUG") == "1"
_G.enable_verilua_debug = enable_verilua_debug

if enable_verilua_debug == true then
    _G.verilua_debug = function (...)
        io.write("\27[31m") -- RED
        print(_G.debug_str("[VERILUA DEBUG]", ...), "\27[0m")
        io.flush()
    end
else
    _G.verilua_debug = function (...)
    end
end

_G.verilua_info = function (...)
    io.write("\27[36m") -- CYAN
    print("[VERILUA INFO]", ..., "\27[0m")
end

_G.verilua_warning = function (...)
    io.write("\27[33m") -- YELLOW
    print("[VERILUA WARNING]", ..., "\27[0m")
    io.flush()
end

_G.verilua_error = function (...)
    local error_print = function(...)
        io.write("\27[31m") -- RED
        print("[VERILUA ERROR]", ..., "\27[0m")
        io.flush()
    end
    assert(false, error_print(...))
end

_G.verilua_assert = function (cond, ...)
    if cond == nil or cond == false then
        _G.verilua_error(...)
    end
end

_G.verilua_hello = function ()
    -- Generated by: http://www.patorjk.com/software/taag
    local hello = [[   
____   ____                .__ .__                  
\   \ /   /  ____  _______ |__||  |   __ __ _____   
 \   Y   / _/ __ \ \_  __ \|  ||  |  |  |  \\__  \  
  \     /  \  ___/  |  | \/|  ||  |__|  |  / / __ \_
   \___/    \___  > |__|   |__||____/|____/ (____  /
                \/                               \/ 
]]
    io.write("\27[36m") -- CYAN
    print(hello, "\27[0m")
    io.flush()
end

-- 
-- load configuration
-- 
_G.cfg = require "LuaSimConfig"
_G.colors = cfg.colors
_G.SchedulerMode = cfg.SchedulerMode

local cfg_name, cfg_path
do
    local path = require "pl.path"
    local stringx = require "pl.stringx"

    cfg_name, cfg_path = cfg:get_user_cfg()
    
    if cfg_name then
        if cfg_path == nil then
            cfg_path = path.abspath(path.dirname(cfg_name)) -- get abs path name
        end
        
        assert(type(cfg_path) == "string")

        if string.len(cfg_path) ~= 0 then
            _G.package.path = _G.package.path .. ";" .. cfg_path .. "/?.lua" 
        end

        cfg_name = path.basename(cfg_name) -- strip basename

        if stringx.endswith(cfg_name, ".lua") then
            cfg_name = stringx.rstrip(cfg_name, ".lua") -- strip ".lua" suffix
        end

        local _cfg = require(cfg_name)
        assert(type(_cfg) == "table", f("`cfg` is not a `table`, maybe there is package conflict. cfg_name:%s cfg_path:%s", cfg_name, cfg_path))

        cfg:merge_config(_cfg)
    end
    cfg:post_config()
end
_G.verilua_get_error = false -- Set by each scheduler when there is an error in the ongoing task

-- 
-- add source_file/dependencies package path
-- 
do
    for _, src in ipairs(cfg.srcs) do
        _G.package.path = _G.package.path .. ";" .. src
    end

    for _, dep in pairs(cfg.deps) do
        _G.package.path = package.path .. ";" .. dep
    end
end

-- 
-- we should load ffi setenv before setting up other environment variables
-- 
_G.ffi = require "ffi"
ffi.cdef[[
    int setenv(const char *name, const char *value, int overwrite);
    int verilator_get_mode(void);
]]

do
    ffi.cdef[[
        typedef struct timespec {
            long sec;
            long nsec;
        } timespec;
        int clock_gettime(int clk_id, struct timespec *tp);
    ]]

    -- High performance implementation of `os.clock()` using LuaJIT FFI
    local CLOCK_MONOTONIC = 1
    local t = ffi.new("timespec[1]")
    local C = ffi.C
    os._clock = os.clock
    os.clock = function()
        C.clock_gettime(CLOCK_MONOTONIC, t)
        return tonumber(t[0].sec) + tonumber(t[0].nsec) * 1e-9
    end
end

if cfg.simulator == "vcs" then
    ffi.cdef[[
        int vcs_get_mode(void);
        void *svGetScopeFromName(const char *str);
        void svSetScope(void *scope);
    ]]
end

-- 
-- setup breakpoint
-- 
_G.bp = function() print("[Breakpoint] Invalid breakpoint!") end
if os.getenv("VL_DEBUGGER") == "1" then
    _G.verilua_debug("VL_DEBUGGER is 1")
    _G.bp = function() 
        require("LuaPanda").start("localhost", 8818)
        ---@diagnostic disable-next-line: undefined-global
        local ret = LuaPanda and LuaPanda.BP and LuaPanda.BP()
    end
end

--
-- Setup some environment variables
-- 
do
    local function setenv_from_lua(name, value)
        assert(type(name) == "string")
        assert(value ~= nil)
        local ret = ffi.C.setenv(name, tostring(value), 1)
        if ret == 0 then
            _G.verilua_debug("Environment variable <%s> set successfully.", name)
        else
            _G.verilua_debug("Failed to set environment variable <%s>.", name)
        end
    end

    -- 
    -- setup LUA_SCRIPT inside init.lua, this can be overwrite by outer environment variable
    -- 
    local LUA_SCRIPT = cfg.script
    if LUA_SCRIPT ~= nil then
        setenv_from_lua("LUA_SCRIPT", LUA_SCRIPT)
    end

    -- 
    -- setup VL_DEF_VPI_LEARN inside init.lua, this can be overwrite by outer environment variable
    -- 
    local VL_DEF_VPI_LEARN = cfg.vpi_learn
    if VL_DEF_VPI_LEARN ~= nil then
        setenv_from_lua("VL_DEF_VPI_LEARN", VL_DEF_VPI_LEARN)
    end

    -- 
    -- setup DUT_TOP inside init.lua, this can be overwrite by outer environment variable
    -- 
    local DUT_TOP = cfg.top
    if DUT_TOP ~= nil then
        setenv_from_lua("DUT_TOP", DUT_TOP)
    end

    setenv_from_lua("LUA_PATH", _G.package.path)

    ---@class oslib
    ---@field setenv fun(name: string, value: string|number)

    os.setenv = setenv_from_lua
end

-- 
-- setup mode
-- 
do
    if cfg.simulator == "verilator" or cfg.simulator == "vcs" then
        if not cfg.is_hse then
            if cfg.simulator == "vcs" then
                ffi.C.svSetScope(ffi.C.svGetScopeFromName(cfg.top))

                local success, mode = pcall(function () return ffi.C.vcs_get_mode() end)
                if not success then
                    mode = cfg.SchedulerMode.NORMAL
                    _G.verilua_warning("cannot found ffi.C.vcs_get_mode(), using default mode NORMAL")
                end
                cfg.mode = tonumber(mode)
            else
                assert(cfg.simulator == "verilator", "For now, only support Verilator")
                local mode = ffi.C.verilator_get_mode()
                cfg.mode = tonumber(mode)
            end
        else
            if cfg.mode == "nil" then
                cfg.mode = cfg.SchedulerMode.STEP
            else
                assert(cfg.mode == cfg.SchedulerMode.STEP or cfg.mode == cfg.SchedulerMode.EDGE_STEP, "For now, `cfg.mode` only support SchedulerMode.STEP/\"step\" or SchedulerMode.EDGE_STEP/\"edge_step\" when `cfg.is_hse` is `true`, but currently `cfg.mode` is " .. tostring(cfg.mode))
            end
        end
        _G.verilua_debug("SchedulerMode is " .. cfg.SchedulerMode(cfg.mode))
    end
end

-- 
-- import scheduler functions
-- 
local scommon = require "verilua.scheduler.LuaSchedulerCommonV2"
for key, value in pairs(scommon) do
    _G[key] = value
end

-- 
-- Table extension
-- 
---@class tablelib
---@field join fun(...): table
---@field contains fun(t: table, v: any): boolean
table.join = function (...)
    local result = {}
    for _, t in ipairs({...}) do
        if type(t) == "table" then
            for k, v in pairs(t) do
                if type(k) == "number" then table.insert(result, v)
                else result[k] = v end
            end
        else
            table.insert(result, t)
        end
    end
    return result
end
table.contains = function (t, v)
    for _, _v in ipairs(t) do
        if _v == v then return true end
    end
    return false
end

-- 
-- try-catch-finally(https://xmake.io/#/manual/builtin_modules?id=try-catch-finally)
-- Has the same functionality as the try-catch-finally in xmake
-- 
do
    local table_join = table.join
    local table_pack = table.pack
    local table_unpack = table.unpack
    local debug_traceback = debug.traceback
    local xpcall = xpcall

    ---@type fun(block: table<function>): table<function>
    _G.catch = function (block)
        return {catch = block[1]}
    end

    ---@type fun(block: table<function>): table<function>
    _G.finally = function (block)
        return {finally = block[1]}
    end

    --- Example:
    --- ```lua
    ---     try
    ---     {
    ---         -- try code block
    ---         function ()
    ---             error("error message")
    ---         end,
    ---
    ---         -- catch code block
    ---         catch
    ---         {
    ---             -- After an exception occurs, it is executed
    ---             function (errors)
    ---                 print(errors)
    ---             end
    ---         },
    ---
    ---         -- finally block
    ---         finally
    ---         {
    ---             -- Finally will be executed here
    ---             function (ok, errors)
    ---                 -- If there is an exception in try{}, ok is true, errors is the error message, otherwise it is false, and error is the return value in try
    ---             end
    ---         }
    ---     }
    --- ```
    ---@type fun(block: table<function>): ...
    _G.try = function (block)

        -- get the try function
        local try = block[1]
        assert(try)

        -- get catch and finally functions
        local funcs = table_join(block[2] or {}, block[3] or {})

        -- try to call it
        local results = table_pack(xpcall(try, function (errors) return "[try-catch-finally] " .. debug_traceback(errors) end))
        local ok = results[1]
        if not ok then
            -- run the catch function
            if funcs and funcs.catch then
                funcs.catch(results[2])
            end
        end

        -- run the finally function
        if funcs and funcs.finally then
            funcs.finally(ok, table_unpack(results, 2, results.n))
        end

        if ok then
            return table_unpack(results, 2, results.n)
        end
    end
end

-- 
-- string operate extension
-- 
local vpiml = require "vpiml"
local CallableHDL = require "verilua.handles.LuaCallableHDL"
local Bundle = require "verilua.handles.LuaBundle"
local AliasBundle = require "verilua.handles.LuaAliasBundle"
local CoverGroup = require "verilua.coverage.CoverGroup"
local CoverPoint = require "verilua.coverage.CoverPoint"
local AccurateCoverPoint = require "verilua.coverage.AccurateCoverPoint"
local utils = require "verilua.LuaUtils"
local BitVec = require "verilua.utils.BitVec"

local stringx = require "pl.stringx"
do

---@class (exact) string.abdl.params
---@field hier string
---@field prefix string
---@field name string
---@field [string] string|number

---@class (exact) string.bdl.params
---@field hier string
---@field prefix? string
---@field is_decoupled? boolean
---@field name? string
---@field optional_signals? table<string>

---@class (exact) string.tcc_compile.sym_ptr_tbl
---@field sym string
---@field ptr string

---@class string.fake_chdl.overload_func_tbl
---@field get? fun(self: CallableHDL, force_multi_beat?: boolean): number|MultiBeatData
---@field get64? fun(self: CallableHDL): uint64_t
---@field set? fun(self: CallableHDL, value: number|uint64_t|table<number>, force_single_beat?: boolean)
---@field set_force? fun(self: CallableHDL, value: number|uint64_t|table<number>, force_single_beat?: boolean)
---@field set_imm? fun(self: CallableHDL, value: number|uint64_t|table<number>, force_single_beat?: boolean)
---@field get_hex_str? fun(self: CallableHDL): string
---@field is? fun(self: CallableHDL, value: number|ffi.cdata*): boolean
---@field is_not? fun(self: CallableHDL, value: number|ffi.cdata*): boolean

---@class string.ext
---@field render fun(template: string, vars: table): string
---@field strip fun(str: string, suffix: string): string
---@field join fun(str: string, list: table): string
---@field number fun(str: string): number
---@field contains fun(str: string, target: string): boolean
---@field hdl fun(hierpath: string): ComplexHandleRaw
---@field chdl fun(hierpath: string, hdl?: ComplexHandleRaw): CallableHDL
---@field fake_chdl fun(hierpath: string, overload_func_tbl: string.fake_chdl.overload_func_tbl): CallableHDL
---@field bundle fun(str: string, params: string.bdl.params): Bundle
---@field set fun(str: string, value: number)
---@field set_force fun(str: string, value: number)
---@field set_release fun(str: string)
---@field get fun(str: string): number
---@field posedge fun(str: string)
---@field negedge fun(str: string)
---@field posedge_until fun(str: string, max_limit?: number, fun?: fun(i: number)): boolean
---@field negedge_until fun(str: string, max_limit?: number, fun?: fun(i: number)): boolean
---@field bdl fun(str: string, params: string.bdl.params): Bundle
---@field abdl fun(str: string, params_table: string.bdl.params): AliasBundle
---@field ehdl fun(this: string, event_id_integer?: integer): EventHandle
---@field auto_bundle fun(str: string, params_table: SignalDB.auto_bundle.params): Bundle
---@field tcc_compile fun(str: string, sym_ptr_tbls: string.tcc_compile.sym_ptr_tbl[]): table<any>
---@field enum_define fun(name: string, enum_table: table<any>): table<any>
---@field bv fun(init_hex_str: string, bitwidth?: number): BitVec
---@field bit_vec fun(init_hex_str: string, bitwidth?: number): BitVec

---@class stringlib: string.ext

----------------------------------------------------------------------
-- Basic string extension, for enhancing string operation
----------------------------------------------------------------------
    -- 
    -- Example:
    --      local template = "Hello {{name}}!"
    --      local rendered_template = template:render({name = "Bob"})
    --      assert(rendered_template == "Hello Bob!")
    -- 
    string.render = function(template, vars)
        assert(type(template) == "string", "[render] template must be a `string`")
        assert(type(vars) == "table", "[render] vars must be a `table`")
        return (template:gsub("{{(.-)}}", function(key)
            if vars[key] == nil then
                assert(false, f("[render] key not found: %s\n\ttemplate_str is: %s\n" , key, template))
            end
            return tostring(vars[key] or "")
        end))
    end

    -- 
    -- Example:
    --      assert(("hello.lua"):strip(".lua") == "hello")
    --      assert(("hello"):strip(".lua") == "hello")
    -- 
    string.strip = function(str, suffix)
        assert(type(suffix) == "string", "suffix must be a string")
        if str:sub(-#suffix) == suffix then
            return str:sub(1, -#suffix - 1)
        else
            return str
        end
    end

    -- 
    -- Example: 
    --      (" "):join {1, 2, 3}    ==>  "1 2 3"
    --      ("-"):join {1, 2, 3}    ==>  "1-2-3"
    --      ("-"):join {1, 2, 3, "str"} ==> "1-2-3-str"
    -- 
    string.join = function(str, list)
        return stringx.join(str, list)
    end

    -- 
    -- Example: 
    --      ("0b11"):number()    ==> 3
    --      ("0x11"):number()    ==> 17
    --      ("123"):number()     ==> 123
    --      local hex_str = "0x11"
    --      hex_str:number()     ==> 17
    -- 
    string.number = function(str)
        if str:sub(1, 2) == "0b" then
            -- binary transform
            return tonumber(str:sub(3), 2)
        elseif str:sub(1, 2) == "0x" then
            -- hex transform
            return tonumber(str:sub(3), 16)
        else
            return tonumber(str) --[[@as number]]
        end
    end
    
    -- 
    -- Example:
    --      ("hello world"):contains("hello") ==> true
    --      ("hello world"):contains("hell")  ==> false
    -- 
    string.contains = function(str, target)
        local startIdx, _ = str:find(target)
        if startIdx then
            return true
        else
            return false
        end
    end


----------------------------------------------------------------------
-- Hardware related string extension, including handles used for 
-- accessing internal hardware signals
----------------------------------------------------------------------
    -- 
    -- Get vpi handle using native stirng metatable
    -- Example: 
    --      local hdl_path = "tb_top.cycles"
    --      local hdl = hdl_path:hdl()
    --  
    --      local hdl = ("tb_top.clock"):hdl()
    -- 
    string.hdl = function(str)
        local hdl = vpiml.vpiml_handle_by_name_safe(str)

        if hdl == -1 then
            assert(false, f("[hdl] no handle found => %s", str))
        end

        return hdl
    end

    -- 
    -- Get CallableHDL using native stirng metatable
    -- Example:
    --      local cycles_chdl = ("tb_top.cycles"):chdl()
    --      print("value of cycles is " .. cycles_chdl:get())
    --      cycles_chdl:set(123)
    -- 
    string.chdl = function(hierpath, hdl)
        return CallableHDL(hierpath, "", hdl)
    end

    -- 
    -- Create a fake CallableHDL as a placeholder for maintaining compatibility
    -- Example:
    --      local cycles_chdl = ("tb_top.cycles"):fake_chdl({
    --          get = function() return 0 end,
    --          set = function(val) end
    --      })
    -- 
    string.fake_chdl = function (hierpath, overload_func_tbl)
        ---@type CallableHDL
        ---@diagnostic disable-next-line: missing-fields
        local chdl = {
            __type = "CallableHDL",
            name = "fake_chdl__" .. hierpath,
            fullpath = hierpath,
        }

        for k, v in pairs(overload_func_tbl) do
            chdl[k] = v
        end

        setmetatable(chdl, {
            __index = function(self, key)
                assert(false, f("[fake_chdl] Cannot access key: %s, key no found!", key))
            end,
        })

        return chdl
    end

    local function to_normal_table(org_tbl)
        local ret = {}
        for key, value in pairs(org_tbl) do
            table.insert(ret, value)
        end
        return ret
    end

    -- 
    -- get LuaBundle using native string metatable
    -- Example:
    --      local bdl = ("field1|field2|field3"):bundle {hier = "tb_top"} -- hier is the only one mandatory params to be passed into this constructor
    --      local bdl = ("valid | ready | opcode | data"):bundle {hier = "tb_top", is_decoupled = true}    
    --      local bdl = ("| valid | ready | opcode | data"): bundle {hier = "tb_top"}
    --      local bdl = ("| valid | ready | opcode | data |"): bundle {hier = "tb_top"}
    --      local strange_bdl = ([[
    --          field1 |
    --          field2     |
    --          field3 
    --      ]]):bundle {hier = "tb_top", name = "strange hdl name"}
    --      local beautiful_bdl = ([[
    --          field1  |
    --          field2  |
    --          field3  |
    --          field4  
    --      ]]):bundle {hier = "tb_top", prefix = "p_"}
    --      local beautiful_bdl_1 = ([[
    --          | field1 |
    --          | field2 |
    --          | field3 |
    --      ]]):bundle {hier = "tb_top", prefix = "p_"}
    --  
    --      local bdl_str = ("|"):join {"valid", "ready", "address", "opcode", "param", "source", "data"} -- bdl_str ==> "valid|ready|address|opcode|param|source|data"
    --      local bdl = bdl_str:bundle {hier = cfg.top .. ".u_TestTop_fullSys_1Core.l2", is_decoupled = true, name = "Channel A", prefix = "auto_in_a_"}
    -- 
    local process_bundle = function(str, params_table)
        local signals_table = stringx.split(str, "|")
        local will_remove_idx = {}

        for i = 1, #signals_table do
            -- remove trivial characters
            signals_table[i] = stringx.replace(signals_table[i], " ", "")
            signals_table[i] = stringx.replace(signals_table[i], "\n", "")
            signals_table[i] = stringx.replace(signals_table[i], "\t", "")

            if signals_table[i] == "" then
                -- not a valid signal
                table.insert(will_remove_idx, i)
            end
        end

        -- remove invalid signal
        for index, value in ipairs(will_remove_idx) do
            signals_table[value] = nil
        end

        assert(type(params_table) == "table")

        -- turn into simple lua table
        local _signals_table = to_normal_table(signals_table)

        local hier = params_table.hier
        local hier_type = type(params_table.hier)
        
        assert(hier ~= nil, "[bundle] hierachy is not set! please set by `hier` field ")
        assert(hier_type == "string", "[bundle] invalid hierarchy type => " .. hier_type)

        local prefix = ""
        local is_decoupled = true
        local name = "Unknown"
        local optional_signals = nil
        for key, value in pairs(params_table) do
            if key == "prefix" then
                assert(type(value) == "string")
                prefix = value
            elseif key == "is_decoupled" then
                assert(type(value) == "boolean" )
                is_decoupled =  value
            elseif key == "name" then
                assert(type(value) == "string")
                name = value
            elseif key == "optional_signals" then
                assert(type(value) == "table")
                if #value > 0 then
                    assert(type(value[1]) == "string")
                end
                optional_signals = value
            elseif key == "hier" then
                -- pass
            else
                assert(false, "[bundle] unkonwn key => " .. tostring(key) .. " value => " .. tostring(value) .. ", available keys: `prefix`, `is_decoupled`, `name`, `optional_signals`, `hier`")
            end
        end

        return Bundle(_signals_table, prefix, hier, name, is_decoupled, optional_signals)
    end
    string.bundle = process_bundle
    string.bdl = process_bundle

    -- 
    -- Example:
    --      local cycles_str = "tb_top.cycles"
    --      cycles_str:set(0x123)
    --      cycles_str:set("0x123")
    --      cycles_str:set("0b111")
    -- 
    string.set = function (str, value)
        vpiml.vpiml_set_value(vpiml.vpiml_handle_by_name(str), tonumber(value))
    end

    -- 
    -- Example: 
    --      local cycles_str = "tb_top.cycles"
    --      cycles_str:set_force(1)   -- force handle
    --      ...
    --      cycles_str:set_release()  -- release handle
    -- 
    string.set_force = function (str, value)
        vpiml.vpiml_force_value(vpiml.vpiml_handle_by_name(str), tonumber(value))
    end
    string.set_release = function (str)
        vpiml.vpiml_release_value(vpiml.vpiml_handle_by_name(str))
    end

    -- 
    -- Example:
    --      local cycles_hdl = "tb_top.cycles"
    --      local value_of_cycles = cycles_str:get()
    --      local value_of_cycles = ("tb_top.cycles"):get()
    -- 
    string.get = function (str)
        return tonumber(vpiml.vpiml_get_value(vpiml.vpiml_handle_by_name(str))) --[[@as number]]
    end
    
    -- 
    -- Example:
    --      local str = "tb_top.clock"
    --      str:posedge()
    -- 
    -- 
    string.posedge = function (str)
        _G.await_posedge(str)
    end
    string.negedge = function (str)
        _G.await_negedge(str)
    end

    -- 
    -- Examplel:
    --      local clock_str = "tb_top.clock"
    --      local ok = clock_str:posedge_until(1000, function ()
    --          return dut.cycles() >= 100
    --      end)
    --      
    --      local ok = ("tb_top".clock):posedge_until(1000, function ()
    --          return dut.cycles() >= 100
    --      end)
    -- 
    string.posedge_until = function (this, max_limit, func)
        assert(max_limit ~= nil)
        assert(type(max_limit) == "number")
        assert(max_limit >= 1)

        assert(func ~= nil)
        assert(type(func) == "function") 

        local condition_meet = false
        for i = 1, max_limit do
            condition_meet = func(i)
            assert(condition_meet ~= nil and type(condition_meet) == "boolean")

            if not condition_meet then
                _G.await_posedge(this)
            else
                break
            end
        end

        return condition_meet
    end
    string.negedge_until = function (this, max_limit, func)
        assert(max_limit ~= nil)
        assert(type(max_limit) == "number")
        assert(max_limit >= 1)

        assert(func ~= nil)
        assert(type(func) == "function") 

        local condition_meet = false
        for i = 1, max_limit do
            condition_meet = func(i)
            assert(condition_meet ~= nil and type(condition_meet) == "boolean")

            if not condition_meet then
                _G.await_negedge(this)
            else
                break 
            end
        end

        return condition_meet
    end

    -- 
    -- Example:
    --      local test_ehdl = ("test_1"):ehdl() -- event_id will be randomly allocated
    --      test_ehdl:wait()
    --      test_ehdl:send()
    --      
    --      local test_ehdl = ("test_1"):ehdl(1) -- manually set event_id
    -- 
    local scheduler = require "verilua.scheduler.LuaScheduler"
    assert(scheduler ~= nil)
    string.ehdl = function (this, event_id_integer)
        ---@diagnostic disable-next-line: invisible
        return scheduler:get_event_hdl(this, event_id_integer)
    end


    -- 
    --  Example:
    --      local abdl = ([[
    --          | origin_signal_name => alias_name
    --          | origin_signal_name_1 => alias_name_1
    --      ]]):abdl {hier = "path.to.hier", perfix = "some_prefix_", name = "name of alias bundle"}
    --      local value = abdl.alias_name:get()    -- real signal is <path.to.hier.some_prefix_origin_signal_name>
    --      abdl.alias_name_1:set(123) 
    --
    --      local abdl = ([[
    --          | origin_signal_name
    --          | origin_signal_name_1 => alias_name_1
    --      ]]):abdl {hier = "top", prefix = "prefix"}
    --      local value = abdl.origin_signal_name:get()
    --      abdl.alias_name_1:set(123)
    --      
    --      local abdl = ([[
    --          | {p}_value => val_{b}
    --          | {b}_opcode => opcode
    --      ]]):abdl {hier ="hier", prefix = "prefix_", p = "hello", b = 123}
    --      local value = abdl.val_123:get()     -- real signal is <hier.prefix_hello_value>
    -- 
    string.abdl = function (str, params_table)
        ---@cast str string
        ---@cast params_table string.abdl.params

        local signals_table = stringx.split(str, "|")
        local will_remove_idx = {}

        for i = 1, #signals_table do
            -- remove trivial characters
            signals_table[i] = stringx.replace(signals_table[i], " ", "")
            signals_table[i] = stringx.replace(signals_table[i], "\n", "")
            signals_table[i] = stringx.replace(signals_table[i], "\t", "")

            if signals_table[i] == "" then
                -- not a valid signal
                table.insert(will_remove_idx, i)
            end
        end

        -- remove invalid signal
        for index, value in ipairs(will_remove_idx) do
            signals_table[value] = nil
        end

        assert(type(params_table) == "table")

        -- turn into simple lua table
        local _signals_table = to_normal_table(signals_table)

        -- replace some string literal with other <value>
        local pattern = "{[^%{%}%(%)]*}"
        for i = 1, #_signals_table do
            local matchs = string.gmatch(_signals_table[i], pattern)
            for match in matchs do
                local repl_key = string.gsub(string.gsub(match, "{", ""), "}", "")
                local repl_value = params_table[repl_key]
                local repl_value_str = tostring(repl_value)
                assert(repl_value ~= nil, f("[abdl] replace key: <%s> not found in <params_table>!", repl_key))

                _signals_table[i] = string.gsub(_signals_table[i], match, repl_value_str)
            end
        end

        local alias_tbl = {}
        for i = 1, #_signals_table do
            local tmp = stringx.split(_signals_table[i], "=>")
            assert(tmp[1] ~= nil)
            assert(type(tmp[1]) == "string")
            if tmp[2] ~= nil then
                assert(type(tmp[2]) == "string")
                table.insert(alias_tbl, {tmp[1], tmp[2]})
            else
                table.insert(alias_tbl, {tmp[1]})
            end
        end

        local hier = params_table.hier
        local hier_type = type(params_table.hier)

        assert(hier ~= nil, "[abdl] hierachy is not set! please set by `hier` field ")
        assert(hier_type == "string", "[abdl] invalid hierarchy type => " .. hier_type)

        local prefix = ""
        local name = "Unknown"
        local optional_signals = nil
        for key, value in pairs(params_table) do
            if key == "prefix" then
                assert(type(value) == "string", "[abdl] invalid type for the `prefix` field, valid type: `string`")
                prefix = value
            elseif key == "name" then
                assert(type(value) == "string", "[abdl] invalid type for the `name` field, valid type: `string`")
                name = value
            elseif key == "optional_signals" then
                assert(type(value) == "table")
                if #value > 0 then
                    assert(type(value[1]) == "string")
                end
                optional_signals = value
            end
        end

        return AliasBundle(alias_tbl, prefix, hier, name, optional_signals)
    end

    -- 
    -- Create a `Bundle` with the signals which meet the certain conditions
    --  
    -- Example:
    --      local bdl = ("tb_top.path.to.mod"):auto_bundle { startswith = "io_in_", endswith = "_value" }
    --      local bdl = ("tb_top.path.to.mod"):auto_bundle { startswith = "io_in_" }
    --      local bdl = ("tb_top.path.to.mod"):auto_bundle { endswith = "_value" }
    --      local bdl = ("tb_top.path.to.mod"):auto_bundle { matches = "^io_" }
    --      local bdl = ("tb_top.path.to.mod"):auto_bundle { filter = function (name, width)
    --          return width == 32 and name:endswith("_value")
    --      end }
    -- 
    string.auto_bundle = function (str, params_table)
        return require("SignalDB"):auto_bundle(str, params_table)
    end


----------------------------------------------------------------------
-- Functional coverage related string extension
----------------------------------------------------------------------
    -- The verilua holds a default coverage group. 
    -- User can create a coverage point without manually creating a new coverage group for convenience.
    local default_cg = CoverGroup("default")
    _G.default_cg = default_cg

    -- 
    -- Example:
    --      Basic usage:
    --          (1) Create coverage handle
    --              local c1 = ("name of cover point"):cvhdl()     -- This cover point belongs to the `default_cg` if no extra parameters are provided.
    --          (2) Accumulate cover point value by <cvhdl>:inc()
    --              c1:inc()
    --          (3) Report current coverage status by <coverage group>:report()
    --              default_cg:report()
    --          (4) Reset cover point by <cvhdl>:reset()
    --              c1:reset()
    --          (5) Save coverage report into a `json` file
    --              default_cg:save()  -- The `default_cg` will be automatically saved if there are coverage points registered by the user.
    --                                 -- User does not required to manually call this function to save the `default_cg` into `json` file.
    --                                 -- For the user defined coverage groups, user should save it in some place and those coverage groups
    --                                 -- are not controlled by the verilua kernel.
    -- 
    --      Use user defined coverage group:
    --          local CoverGroup = require "coverage.CoverGroup"
    --          local user_defined_cg = CoverGroup("user_defined")
    --          local c2 = ("some cover point"):cvhdl { group = user_defined_cg }
    --          c2:inc()
    --          user_defined_cg:report()
    --          user_defined_cg:save()
    -- 
    --      Accurate cover point(The accurate cover point will save the cycle time when cover point accumulate the internel counter):
    --          local accurate_cp = ("some accurate cover point"):cvhdl { type = "accurate" }
    --          accurate_cp:inc_with_cyclce(<cycle value>)    -- Use inc_with_cycle() instead of inc() for the accurate cover point
    -- 
    getmetatable('').__index.cvhdl = function(name, params_table)
        local cover_group = default_cg
        local cover_point_type = "simple"

        if params_table then
            local params_table_type = type(params_table)
            assert(params_table_type == "table")

            for key, value in pairs(params_table) do
                -- User defined CoverGroup
                if key == "group" then
                    local value_type = type(value)
                    if value_type ~= "table" then
                        assert(false, "[cvhdl] invalid `group` type! you should provide a valid CoverGroup. invalid_type => " .. value_type)
                    else
                        assert(value.__type == "CoverGroup", "[cvhdl] the provided `group` did not contains `type` field! you should pass a valid CoverGroup")
                    end
                    cover_group = value
                
                -- Type of the CoverPoint
                elseif key == "type" then
                    if value ~= "simple" and value ~= "accurate" then
                        assert(false, "[cvhdl] invalid cover point type: " .. value .. ", available type: `simple`, `accurate`")
                    end
                    cover_point_type = value
                else
                    assert(false, "[cvhdl] invalid key: " .. key .. ", available keys: `group`") 
                end
            end 
        end
        
        local cover_point
        if cover_point_type == "simple" then
            cover_point = CoverPoint(name, cover_group)
            cover_group:add_cover_point(cover_point)
        elseif cover_point_type == "accurate" then
            cover_point = AccurateCoverPoint(name, cover_group)
            cover_group:add_cover_point(cover_point)
        else
            assert(false, "[cvhdl] invalid cover point type: " .. cover_point_type)
        end

        return cover_point
    end

    -- Alias of <string>:cvhdl()
    getmetatable('').__index.cover_point = function (name, params_table)
        name:cvhdl(params_table)
    end


----------------------------------------------------------------------
-- Other miscellaneous string extension
----------------------------------------------------------------------
    -- 
    --  Example:
    --    local lib = ([[
    --        #include "stdio.h"
    --
    --        int count = 0;
    --
    --        // $sym<hello> $ptr<void (*)(void)>
    --        void hello() {
    --            printf("hello %d\n", count);
    --            count++;
    --        }
    --
    --        // $sym<get_count> $ptr<int (*)(void)>
    --        int get_count() {
    --            return count;
    --        }
    --    ]]):tcc_compile()
    --    
    ------- OR -------
    --
    --    local lib = ([[
    --        #include "stdio.h"
    --
    --        int count = 0;
    --
    --        void hello() {
    --            printf("hello %d\n", count);
    --            count++;
    --        }
    --
    --        int get_count() {
    --            return count;
    --        }
    --    ]]):tcc_compile({ {sym = "hello", ptr = "void (*)(void)"}, {sym = "get_count", ptr = "int (*)(void)"} })
    --
    --     lib.hello()
    --     assert(lib.get_count() == 1)
    -- 
    string.tcc_compile = function(str, sym_ptr_tbls)
        local tcc = require "TccWrapper"
        local state = tcc.new()
        assert(state:set_output_type(tcc.OUTPUT.MEMORY))
        assert(state:compile_string(str))
        assert(state:relocate(tcc.RELOCATE.AUTO))

        local verilua_debug = _G.verilua_debug

        local count = 0
        local lib = {_state = state} -- keep `state` alive to prevent GC

        for line in string.gmatch(str, "[^\r\n]+") do
            local symbol_name = line:match("%$sym<%s*([^>]+)%s*>")
            local symbol_ptr_pattern = line:match("%$ptr%s*<%s*([^>]+)%s*>")
            if symbol_name or symbol_ptr_pattern then
                count = count + 1
                verilua_debug("[tcc_compile] [" .. count .. "] find symbol_name => \"" .. (symbol_name or "nil") .. "\"")
                verilua_debug("[tcc_compile] [" .. count .. "] find symbol_ptr_pattern = \"" .. (symbol_ptr_pattern or "nil") .. "\"")
                local sym = assert(state:get_symbol(symbol_name))
                lib[symbol_name] = ffi.cast(symbol_ptr_pattern, sym)
            end
        end

        if sym_ptr_tbls ~= nil then
            assert(type(sym_ptr_tbls) == "table")
            assert(type(sym_ptr_tbls[1]) == "table")
            for _, sym_ptr_tbl in ipairs(sym_ptr_tbls) do
                local symbol_name = assert(sym_ptr_tbl.sym)
                local symbol_ptr_pattern = assert(sym_ptr_tbl.ptr)
                count = count + 1
                verilua_debug("[tcc_compile] [" .. count .. "] [sym_ptr_tbls] find symbol_name => \"" .. (symbol_name or "nil") .. "\"")
                verilua_debug("[tcc_compile] [" .. count .. "] [sym_ptr_tbls] find symbol_ptr_pattern = \"" .. (symbol_ptr_pattern or "nil") .. "\"")
                local sym = assert(state:get_symbol(symbol_name))
                lib[symbol_name] = ffi.cast(symbol_ptr_pattern, sym)
            end
        end

        assert(count > 0, f("\n[tcc_compile] Did not find any symbols! Please specify symbol_name or symbol_ptr_pattern in tcc code by a custom C comment: \"// $sym<SymbolName> $ptr<SymbolPtrPattern>\"! Or you could specify this info by the input table \"<string>:tcc_compile({{sym = <symbol_name>, ptr = <symbol_ptr_pattern>}, <other...>})\"\nThe tcc code is:\n%s", str))

        return lib
    end

    -- 
    --  Example:
    --    local enum = ("NameOfEnum"):enum_define {
    --        A = 1,
    --        B = 2  
    --    }
    --    
    --    assert(enum.name == "NameOfEnum")
    --    assert(enum.A == 1)
    --    assert(enum.B == 2)
    --    assert(enum(1) == "A")
    --    assert(enum(2) == "B")
    --
    string.enum_define = function (str, enum_table)
        local enum_table = enum_table
        assert(type(enum_table) == "table")

        enum_table.name = str

        return utils.enum_define(enum_table)
    end

    -- 
    -- Example:
    --    local bv = ("dead"):bv(32)
    --    assert(bv:get_bitfield(0, 31) == 0xdead)
    --    assert(bv:get_bitfield_hex_str(0, 31) == "0000dead")
    -- 
    --    local bv2 = ("beef"):bv()
    --    assert(bv2:get_bitfield(0, 31) == 0xbeef)
    --    assert(bv2:get_bitfield_hex_str(0, 31) == "0000beef")
    -- 
    string.bv = function (init_hex_str, bitwidth)
        return BitVec(init_hex_str, bitwidth)
    end
    string.bit_vec = string.bv -- Alias of `string.bv`
end

local scheduler = require "verilua.scheduler.LuaScheduler"
assert(scheduler ~= nil)

local vl = require "Verilua"
local unnamed_task_count = 0
do
    ---@class TaskName: string
    ---@alias TaskFunction fun()

    ---@class _G
    ---@field verilua fun(cmd: string): fun(tbl: table)
    ---@field fork fun(task_table: table<TaskName|number, TaskFunction>)
    ---@field initial fun(task_table: table<TaskName|number, TaskFunction>)
    ---@field final fun(task_table: table<TaskName|number, TaskFunction>)

    local enable_verilua_debug = _G.enable_verilua_debug
    local verilua_debug = _G.verilua_debug

    _G.verilua = function(cmd)
        if enable_verilua_debug then
            verilua_debug(f("[verilua/%s]", cmd), "execute => " .. cmd)
        end

        -- 
        -- Example
        --      verilua "appendTasks" {
        --          another_task = function ()
        --                 -- body
        --          end,
        --          some_task = function ()
        --                 -- body
        --          end
        --      }
        --      local function another_task()
        --           -- body
        --      end
        --      local function some_task()
        --          -- body
        --      end
        --      verilua "appendTasks" {
        --          another_task_name = another_task,
        --          some_task_name = some_task
        --      }
        -- 
        if cmd == "mainTask" or cmd == "appendTasks" then
            return function (task_table)
                assert(type(task_table) == "table")
                for name, func in pairs(task_table) do
                    if type(name) == "number" then
                        name = ("unnamed_task_%d"):format(unnamed_task_count)
                        unnamed_task_count = unnamed_task_count + 1   
                    end

                    if enable_verilua_debug then
                        verilua_debug(f("[verilua/%s]", cmd), "get task name => ", name)
                    end

                    scheduler:append_task(nil, name, func, true) -- (<task_id>, <task_name>, <task_func>, <start_now>)
                end
            end

        -- 
        -- Example:
        --      verilua "finishTask" { function ()
        --            -- body
        --      end }
        -- 
        --      local function some_finish_task()
        --          -- body
        --      end
        --      verilua "finishTask" {
        --          some_finish_task
        --      }
        -- 
        elseif cmd == "finishTask" then
            return function (task_table)
                assert(type(task_table) == "table")
                assert(#task_table == 1)
                local func = task_table[1]
                vl.register_finish_callback(func)
            end

        -- 
        -- Example:
        --      verilua "startTask" { function ()
        --            -- body
        --      end }
        -- 
        --      local function some_start_task()
        --          -- body
        --      end
        --      verilua "startTask" {
        --          some_finish_task
        --      }
        -- 
        elseif cmd == "startTask" then
            return function (task_table)
                assert(type(task_table) == "table")
                assert(#task_table == 1)
                local func = task_table[1]
                vl.register_start_callback(func)
            end

        elseif cmd == "appendFinishTasks" then
            return function (task_table)
                assert(type(task_table) == "table")
                for k, func in pairs(task_table) do
                    assert(type(func) == "function")
                    vl.append_finish_callback(func)
                end
            end

        elseif cmd == "appendStartTasks" then
            return function (task_table)
                assert(type(task_table) == "table")
                for k, func in pairs(task_table) do
                    assert(type(func) == "function")
                    vl.append_start_callback(func)
                end
            end

        elseif cmd == "showTasks" then
            scheduler:list_tasks()
        else
            local available_cmds = {
                "appendTasks",
                "startTask",
                "finishTask",
                "appendStartTasks",
                "appendFinishTasks",
                "showTasks",
            }
            assert(false, "Unknown cmd => " .. cmd .. ", available cmds: " .. _G.inspect(available_cmds))
            ---@diagnostic disable-next-line: missing-return
        end
    end

    _G.fork = function (task_table)
        assert(type(task_table) == "table")
        for name, func in pairs(task_table) do
            if type(name) == "number" then
                name = ("unnamed_fork_task_%d"):format(unnamed_task_count)
                unnamed_task_count = unnamed_task_count + 1   
            end

            if enable_verilua_debug then
                verilua_debug("[fork] get task name => ", name)
            end

            scheduler:append_task(nil, name, func, true) -- (<task_id>, <task_name>, <task_func>, <start_now>)
        end
    end

    -- Joinable fork, it can be used with `join` to wait until all tasks finished
    -- Example:
    --      -- (1) Create a joinable fork
    --      local ehdl = jfork {
    --          some_task = function ()
    --              -- body
    --          end
    --      }
    --      join(ehdl) -- Wait here until the task finished
    -- 
    --      -- (2) Create multiple joinable forks
    --      local ehdl1 = jfork {
    --          some_task1 = function ()
    --              -- body
    --          end
    --      }
    --      local ehdl2 = jfork {
    --          some_task2 = function ()
    --              -- body
    --          end
    --      }
    --      join(ehdl1, ehdl2) -- Wait here until both tasks finished
    -- 
    ---@param one_task_table table<TaskName|number, TaskFunction>
    ---@return EventHandle, TaskID
    _G.jfork = function (one_task_table)
        local ehdl
        local task_id
        local cnt = 0
        assert(type(one_task_table) == "table")
        for name, func in pairs(one_task_table) do
            cnt = cnt + 1
            assert(cnt == 1, "jfork only supports one task")

            if type(name) == "number" then
                name = ("unnamed_fork_task_%d"):format(unnamed_task_count)
                unnamed_task_count = unnamed_task_count + 1
            end

            if enable_verilua_debug then
                verilua_debug("[jfork] get task name => ", name)
            end

            ehdl = (name .. "__jfork_ehdl"):ehdl()
            ehdl.__type = "EventHandleForJFork"
            task_id = scheduler:append_task(nil, name, function()
                func()
                if ehdl:has_pending_wait() then
                    ehdl:send()
                else
                    verilua_debug("[jfork] ehdl has no pending wait, task_name: " .. name)
                end
                ehdl:remove()
            end, true) -- (<task_id>, <task_name>, <task_func>, <start_now>)
        end
        return ehdl, task_id
    end

    -- Join multiple `jfork` tasks(wait until all tasks finished)
    -- This function will block current task until all `jfork` tasks finished
    ---@param ehdl_tbl EventHandle|EventHandle[]
    _G.join = function (ehdl_tbl)
        assert(type(ehdl_tbl) == "table")
        if ehdl_tbl.event_id then
            ---@cast ehdl_tbl EventHandle
            ehdl_tbl:wait()
        else
            ---@cast ehdl_tbl EventHandle[]
            local expect_finished_cnt = 0
            local already_finished_cnt = 0
            local finished_ehdl_vec = {}
            for _, ehdl in ipairs(ehdl_tbl) do
                local e_type = type(ehdl)
                if not(e_type == "table" and ehdl.__type == "EventHandleForJFork") then
                    assert(false, "`join` only supports EventHandle created by `jfork`, got " .. e_type)
                end

                finished_ehdl_vec[ehdl.event_id] = false
                ---@diagnostic disable-next-line: invisible
                table.insert(scheduler.event_task_id_list_map[ehdl.event_id], assert(scheduler.curr_task_id))

                if not scheduler.event_name_map[ehdl.event_id] then
                    already_finished_cnt = already_finished_cnt + 1
                end
            end
            expect_finished_cnt = #ehdl_tbl

            -- Update expect_finished_cnt
            expect_finished_cnt = expect_finished_cnt - already_finished_cnt

            local finished_cnt = 0
            while true do
                -- If all ehdl are already finished, return
                if finished_cnt == expect_finished_cnt then
                    break
                end

                ---@diagnostic disable-next-line: undefined-global
                await_noop()

                finished_cnt = finished_cnt + 1

                ---@diagnostic disable-next-line: invisible
                local curr_wakeup_event_id = assert(scheduler.curr_wakeup_event_id)
                assert(not finished_ehdl_vec[curr_wakeup_event_id])
                finished_ehdl_vec[curr_wakeup_event_id] = true
            end
        end
    end

    _G.initial = function (task_table)
        assert(type(task_table) == "table")
        for k, func in pairs(task_table) do
            assert(type(func) == "function")
            vl.append_start_callback(func)
        end
    end

    _G.final = function (task_table)
        assert(type(task_table) == "table")
        for k, func in pairs(task_table) do
            assert(type(func) == "function")
            vl.append_finish_callback(func)
        end
    end
end

if os.getenv("VL_PREBUILD") == "1" then
    require "verilua.utils.PrebuildHelper"
else
    ---@diagnostic disable-next-line: duplicate-set-field
    _G.prebuild = function ()
        -- do nothing
    end
end

-- 
-- setup random seed
-- 
do
    _G.verilua_debug(f("random seed is %d", cfg.seed))
    math.randomseed(cfg.seed)
end

-- 
-- Implement sorts of SystemVerilog APIs
-- 
_G.urandom = function ()
    return math_random(0, 0xFFFFFFFF)
end

_G.urandom_range = function (min, max)
    if min > max then
        assert(false, "min should be less than or equal to max")
    end
    return math_random(min, max)
end

_G.sim = require "LuaSimulator"

---@type ProxyTableHandle
_G.dut = (require "LuaDut").create_proxy(cfg.top)

---@class _G
---@field GLOBAL_VERILUA_ENV lightuserdata