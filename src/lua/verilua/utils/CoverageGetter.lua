local SymbolHelper
local ffi = require "ffi"
local utils = require "LuaUtils"

local C = ffi.C
local f = string.format
local tonumber = tonumber
local simulator = cfg.simulator

local svSetScope
local svGetScopeFromName
local setDpiScope

-- `coverageCtrl`, `getCoverage` and `getCondCoverage` are generated by `cov_exporter` where `cov_exporter`
-- parse the provided Verilog source files and generate the coverage annotations which will be inserted
-- back into the Verilog source files and after that these functions will be available when
-- source files has been recompiled.
--
-- Notice: These functions are DPI exported functions.(e.g. export "DPI-C")
local coverageCtrl
local getCoverageCount
local getCoverage
local getCondCoverage
local resetCoverage

if simulator == "verilator" then
    -- In `Verilator`, we can't get DPI functions directly by `ffi.cdef` and `ffi.C`, so we use
    -- `SymbolHelper` to get them as a workaround.
    SymbolHelper = require "SymbolHelper"
    svSetScope = SymbolHelper.ffi_cast("void *(*)(void *)", "svSetScope");
    svGetScopeFromName = SymbolHelper.ffi_cast("void *(*)(const char *)", "svGetScopeFromName");

    -- `coverageCtrl`, `getCoverageCount`, `getCoverage`, `getCondCoverage` may be invisible in the symbol table(eliminated by the
    -- linker since they are not used), make sure `-LDFLAGS "-u getCoverage -u getCondCoverage"`
    -- is added to the link flags of `Verilator`.
    coverageCtrl = SymbolHelper.ffi_cast("void (*)(int)", "coverageCtrl");
    getCoverageCount = SymbolHelper.ffi_cast("void (*)(int *, int *)", "getCoverageCount");
    getCoverage = SymbolHelper.ffi_cast("void (*)(double *)", "getCoverage");
    getCondCoverage = SymbolHelper.ffi_cast("void (*)(double *)", "getCondCoverage");
    resetCoverage = SymbolHelper.ffi_cast("void (*)(void)", "resetCoverage");
elseif simulator == "vcs" then
    ffi.cdef [[
        void *svGetScopeFromName(const char *str);
        void svSetScope(void *scope);
        void coverageCtrl(int enable);
        void getCoverageCount(int *total_count, int *total_bin_expr_count);
        void getCoverage(double *value);
        void getCondCoverage(double *value);
        void resetCoverage(void);
    ]]
    svSetScope = C.svSetScope
    svGetScopeFromName = C.svGetScopeFromName
    coverageCtrl = C.coverageCtrl
    getCoverageCount = C.getCoverageCount
    getCoverage = C.getCoverage
    getCondCoverage = C.getCondCoverage
    resetCoverage = C.resetCoverage
else
    assert(false, "[CoverageGetter] For now, only support `Verilator` and `VCS`")
end

---@param hier string
setDpiScope = function(hier)
    svSetScope(svGetScopeFromName(hier))
end

---@alias SvScope ffi.cdata*

---@cast svSetScope fun(scope: SvScope): SvScope
---@cast svGetScopeFromName fun(name: string): SvScope

---@cast coverageCtrl fun(enable: integer)
---@cast getCoverage fun(coverage_value: ffi.cdata*)
---@cast getCondCoverage fun(coverage_value: ffi.cdata*)

---@alias HierPath string
---@alias ModuleName string

---@class (exact) ExportedModule
---@field hierPaths HierPath[]
---@field statistics {binExprCount: number, netCount: number, varCount: number}
---@field subModules ModuleName[]

---@class (exact) CovExporterMetaInfo
---@field exportedModules table<ModuleName, ExportedModule>
---@field hierPathToModuleName table<HierPath, ModuleName>

---@class CoverageGetter Runtime coverage getter
--- This module is used combined with `cov_exporter`. You should use `cov_exporter`
--- to generate the coverage annotations on your Verilog source files first before
--- using this module.
--- For now this module only supports `Verilator` and `VCS`.
---
---@field private coverage_value ffi.cdata*
---@field private getCoverage fun(coverage_value: ffi.cdata*)
---@field private getCondCoverage fun(coverage_value: ffi.cdata*)
---@field private coverageCtrl fun(enable: integer)
---@field private has_cov_meta_info boolean
---@field private cov_meta_info CovExporterMetaInfo?
---@field private module_to_percent_cache table<ModuleName, table<ModuleName, number>>
---@field read_cov_meta_info fun(self: CoverageGetter, cov_meta_info_file?: string): CoverageGetter
---       Read `cov_exporter.meta.json` which is generated by `cov_exporter`.
---       Path: `outdir`/cov_exporter.meta.json where `outdir` is the output directory of `cov_exporter`.
---@field setDpiScope fun(hier: string)
---@field enable_coverage fun(self: CoverageGetter, hier_or_module: string, recursive?: boolean)
---@field disable_coverage fun(self: CoverageGetter, hier_or_module: string, recursive?: boolean)
---@field get_coverage fun(self: CoverageGetter, hier_or_module: string, recursive?: boolean): number
---@field get_cond_coverage fun(self: CoverageGetter, hier: string, recursive?: boolean): number
---@field show_coverage fun(self: CoverageGetter, hier_or_module: string, length?: number, recursive?: boolean)
---@field show_cond_coverage fun(self: CoverageGetter, hier_or_module: string, length?: number, recursive?: boolean)
---@field get_coverage_count fun(self: CoverageGetter, hier: string): number, number
---@field get_total_count fun(self: CoverageGetter, hier: string): number
---@field get_total_bin_expr_count fun(self: CoverageGetter, hier: string): number
---@field reset_coverage fun(self: CoverageGetter, hier_or_module: string, recursive?: boolean)
local CoverageGetter = {
    coverage_value = ffi.new("double[1]"),
    total_count = ffi.new("int[1]"),
    total_bin_expr_count = ffi.new("int[1]"),
    has_cov_meta_info = false,
    cov_meta_info = nil,
    module_to_percent_cache = {},
    setDpiScope = setDpiScope,
    coverageCtrl = coverageCtrl,
    getCoverageCount = getCoverageCount,
    getCoverage = getCoverage,
    getCondCoverage = getCondCoverage,
    resetCoverage = resetCoverage,
}

function CoverageGetter:read_cov_meta_info(cov_meta_info_file)
    if not self.has_cov_meta_info then
        self.has_cov_meta_info = true

        local _cov_meta_info_file = cov_meta_info_file or os.getenv("VL_COV_EXPORTER_META_FILE")
        assert(_cov_meta_info_file,
            "[CoverageGetter] Failed to get meta file path, either provide `cov_meta_info_file` or set `VL_COV_EXPORTER_META_FILE` environment variable")

        local file = io.open(_cov_meta_info_file, "r")
        if not file then
            assert(false, "[CoverageGetter] Failed to open meta file: " .. _cov_meta_info_file)
        else
            local json = require "json"
            self.cov_meta_info = json.decode(file:read("*a"))
            assert(self.cov_meta_info, "[CoverageGetter] Failed to decode meta file: " .. _cov_meta_info_file)
            file:close()
        end
    end
    return self
end

---@param hier_or_module string Hierarchical path of the target module or module name
---@param recursive boolean? Whether to enable coverage recursively
function CoverageGetter:enable_coverage(hier_or_module, recursive)
    if hier_or_module:find("%.") then
        -- Is hier path, because it contains "."
        self.setDpiScope(hier_or_module)
        self.coverageCtrl(1)
    else
        -- Is module name
        if not self.cov_meta_info then
            self:read_cov_meta_info()
        end

        local hier_paths = self.cov_meta_info.exportedModules[hier_or_module].hierPaths
        if not hier_paths then
            assert(false, "[CoverageGetter] Failed to get hier paths from module name: " .. hier_or_module)
        end

        for _, hier_path in ipairs(hier_paths) do
            self.setDpiScope(hier_path)
            self.coverageCtrl(1)
        end

        if recursive then
            for _, sub_module_name in ipairs(self.cov_meta_info.exportedModules[hier_or_module].subModules) do
                self:enable_coverage(sub_module_name, true)
            end
        end
    end
end

---@param hier_or_module string Hierarchical path of the target module or module name
---@param recursive boolean? Whether to disable coverage recursively
function CoverageGetter:disable_coverage(hier_or_module, recursive)
    if hier_or_module:find("%.") then
        -- Is hier path, because it contains "."
        self.setDpiScope(hier_or_module)
        self.coverageCtrl(0)
    else
        -- Is module name
        if not self.cov_meta_info then
            self:read_cov_meta_info()
        end

        local hier_paths = self.cov_meta_info.exportedModules[hier_or_module].hierPaths
        if not hier_paths then
            assert(false, "[CoverageGetter] Failed to get hier paths from module name: " .. hier_or_module)
        end

        for _, hier_path in ipairs(hier_paths) do
            self.setDpiScope(hier_path)
            self.coverageCtrl(0)
        end

        if recursive then
            for _, sub_module_name in ipairs(self.cov_meta_info.exportedModules[hier_or_module].subModules) do
                self:disable_coverage(sub_module_name, true)
            end
        end
    end
end

---@param hier_or_module string Hierarchical path of the target module or module name
---@param recursive boolean? Whether to get coverage recursively
---@return number Coverage value(0.0 ~ 1.0)
function CoverageGetter:get_coverage(hier_or_module, recursive)
    if recursive then
        if not self.cov_meta_info then
            self:read_cov_meta_info()
        end

        local hier
        if hier_or_module:find("%.") then
            hier = hier_or_module
        else
            local module_info = self.cov_meta_info.exportedModules[hier_or_module]
            assert(module_info, "[CoverageGetter] Failed to get module info from module name: " .. hier_or_module)

            local hier_paths = module_info.hierPaths
            if #hier_paths ~= 1 then
                assert(false,
                    f(
                        "[CoverageGetter] Failed to get hier path from module name: %s, multiple hier paths found: { %s } maybe you should use hier path instead",
                        hier_or_module, table.concat(hier_paths, ", ")))
            end

            hier = hier_paths[1]
        end

        local module_name = self.cov_meta_info.hierPathToModuleName[hier]
        if not module_name then
            assert(false, "[CoverageGetter] Failed to get module name from hier path: " .. hier)
        end

        ---@type table<string, number>
        local module_to_percent
        if self.module_to_percent_cache[module_name] then
            module_to_percent = self.module_to_percent_cache[module_name]
        else
            module_to_percent = {}

            local module_info = self.cov_meta_info.exportedModules[module_name]
            if not module_info then
                assert(false, "[CoverageGetter] Failed to get module info from module name: " .. module_name)
            end

            local submodules = module_info.subModules
            if not submodules then
                assert(false, "[CoverageGetter] Failed to get submodules from module info: " .. module_name)
            end

            if #submodules == 0 then
                self.setDpiScope(hier)
                self.getCoverage(self.coverage_value)
                return tonumber(self.coverage_value[0]) --[[@as number]]
            else
                local total_count = 0
                local module_to_count = {}
                for _, submodule in ipairs(submodules) do
                    local submodule_info = self.cov_meta_info.exportedModules[submodule]
                    if not submodule_info then
                        assert(false, "[CoverageGetter] Failed to get submodule info from submodule name: " .. submodule)
                    end

                    local statistics = submodule_info.statistics
                    local count = statistics.netCount + statistics.varCount + statistics.binExprCount
                    total_count = total_count + count * #submodule_info.hierPaths
                    module_to_count[submodule] = count
                end
                local curr_module_count = module_info.statistics.netCount + module_info.statistics.varCount +
                    module_info.statistics.binExprCount
                total_count = total_count + curr_module_count

                for _, submodule in ipairs(submodules) do
                    module_to_percent[submodule] = module_to_count[submodule] / total_count
                end
                module_to_percent[module_name] = curr_module_count / total_count
            end
            self.module_to_percent_cache[module_name] = module_to_percent
        end

        -- Calculate recursive coverage
        local acc_coverage = 0
        for m, percent in pairs(module_to_percent) do
            if m == module_name then
                self.setDpiScope(hier)
                self.getCoverage(self.coverage_value)
                local coverage = tonumber(self.coverage_value[0]) --[[@as number]]
                acc_coverage = acc_coverage + coverage * percent
            else
                local hiers = self.cov_meta_info.exportedModules[m].hierPaths
                for _, h in ipairs(hiers) do
                    self.setDpiScope(h)
                    self.getCoverage(self.coverage_value)
                    local submodule_coverage = tonumber(self.coverage_value[0]) --[[@as number]]
                    acc_coverage = acc_coverage + submodule_coverage * percent
                end
            end
        end

        return acc_coverage
    else
        -- Before calling a `export "DPI-C"` function, you should set the DPI scope first.
        -- Since every module has its own `getCoverage` or `getCondCoverage`, you should
        -- set the DPI scope to the module you want to get the coverage to prevent naming
        -- ambiguity.
        self.setDpiScope(hier_or_module)
        self.getCoverage(self.coverage_value)
        return tonumber(self.coverage_value[0]) --[[@as number]]
    end
end

---@param hier string Hierarchical path of the target module
---@return number Coverage value(0.0 ~ 1.0)
function CoverageGetter:get_cond_coverage(hier, recursive)
    if recursive then
        if not self.cov_meta_info then
            self:read_cov_meta_info()
        end

        local module_name = self.cov_meta_info.hierPathToModuleName[hier]
        if not module_name then
            assert(false, "[CoverageGetter] Failed to get module name from hier path: " .. hier)
        end

        ---@type table<string, number>
        local module_to_percent
        if self.module_to_percent_cache[module_name] then
            module_to_percent = self.module_to_percent_cache[module_name]
        else
            module_to_percent = {}

            local module_info = self.cov_meta_info.exportedModules[module_name]
            if not module_info then
                assert(false, "[CoverageGetter] Failed to get module info from module name: " .. module_name)
            end

            local submodules = module_info.subModules
            if not submodules then
                assert(false, "[CoverageGetter] Failed to get submodules from module info: " .. module_name)
            end

            if #submodules == 0 then
                self.setDpiScope(hier)
                self.getCondCoverage(self.coverage_value)
                return tonumber(self.coverage_value[0]) --[[@as number]]
            else
                local total_count = 0
                local module_to_count = {}
                for _, submodule in ipairs(submodules) do
                    local submodule_info = self.cov_meta_info.exportedModules[submodule]
                    if not submodule_info then
                        assert(false, "[CoverageGetter] Failed to get submodule info from submodule name: " .. submodule)
                    end

                    local statistics = submodule_info.statistics
                    local count = statistics.binExprCount
                    total_count = total_count + count * #submodule_info.hierPaths
                    module_to_count[submodule] = count
                end
                local curr_module_count = module_info.statistics.binExprCount
                total_count = total_count + curr_module_count

                for _, submodule in ipairs(submodules) do
                    module_to_percent[submodule] = module_to_count[submodule] / total_count
                end
                module_to_percent[module_name] = curr_module_count / total_count
            end
            self.module_to_percent_cache[module_name] = module_to_percent
        end

        -- Calculate recursive coverage
        local acc_coverage = 0
        for m, percent in pairs(module_to_percent) do
            if m == module_name then
                self.setDpiScope(hier)
                self.getCondCoverage(self.coverage_value)
                local coverage = tonumber(self.coverage_value[0]) --[[@as number]]
                acc_coverage = acc_coverage + coverage * percent
            else
                local hiers = self.cov_meta_info.exportedModules[m].hierPaths
                for _, h in ipairs(hiers) do
                    self.setDpiScope(h)
                    self.getCondCoverage(self.coverage_value)
                    local submodule_coverage = tonumber(self.coverage_value[0]) --[[@as number]]
                    acc_coverage = acc_coverage + submodule_coverage * percent
                end
            end
        end

        return acc_coverage
    else
        self.setDpiScope(hier)
        self.getCondCoverage(self.coverage_value)
        return tonumber(self.coverage_value[0]) --[[@as number]]
    end
end

---@param hier_or_module string Hierarchical path of the target module or module name
---@param length number? Length of the progress bar
---@param recursive boolean? Whether to calculate recursive coverage value
function CoverageGetter:show_coverage(hier_or_module, length, recursive)
    if hier_or_module:find("%.") then
        local coverage = self:get_coverage(hier_or_module, recursive)
        print(f("[CoverageGetter] show_coverage: %s\n\t%s %.2f%%", hier_or_module,
            utils.get_progress_bar(coverage, length or 20),
            coverage * 100))
    else
        if not self.cov_meta_info then
            self:read_cov_meta_info()
        end

        local hier_paths = self.cov_meta_info.exportedModules[hier_or_module].hierPaths
        if not hier_paths then
            assert(false, "[CoverageGetter] Failed to get hier paths from module name: " .. hier_or_module)
        end

        print(f("[CoverageGetter] show_coverage: %s", hier_or_module))
        for _, hier_path in ipairs(hier_paths) do
            local coverage = self:get_coverage(hier_path, recursive)
            print(f("\t%s\n\t%s %.2f%%", hier_path, utils.get_progress_bar(coverage, length or 20), coverage * 100))
        end
        print("")
    end
end

---@param hier_or_module string Hierarchical path of the target module or module name
---@param length number? Length of the progress bar
---@param recursive boolean? Whether to calculate recursive coverage value
function CoverageGetter:show_cond_coverage(hier_or_module, length, recursive)
    if hier_or_module:find("%.") then
        local coverage = self:get_cond_coverage(hier_or_module, recursive)
        print(f("[CoverageGetter] show_cond_coverage: %s\n\t%s %.2f%%", hier_or_module,
            utils.get_progress_bar(coverage, length or 20), coverage * 100))
    else
        if not self.cov_meta_info then
            self:read_cov_meta_info()
        end

        local hier_paths = self.cov_meta_info.exportedModules[hier_or_module].hierPaths
        if not hier_paths then
            assert(false, "[CoverageGetter] Failed to get hier paths from module name: " .. hier_or_module)
        end

        print(f("[CoverageGetter] show_cond_coverage: %s", hier_or_module))
        for _, hier_path in ipairs(hier_paths) do
            local coverage = self:get_cond_coverage(hier_path, recursive)
            print(f("\t%s\n\t%s %.2f%%", hier_path, utils.get_progress_bar(coverage, length or 20), coverage * 100))
        end
        print("")
    end
end

---@param hier string Hierarchical path of the target module
function CoverageGetter:get_coverage_count(hier)
    self.setDpiScope(hier)
    self.getCoverageCount(self.total_count, self.total_bin_expr_count)
    return tonumber(self.total_count[0]) --[[@as number]], tonumber(self.total_bin_expr_count[0]) --[[@as number]]
end

---@param hier string Hierarchical path of the target module
function CoverageGetter:get_total_count(hier)
    local total_count, _ = self:get_coverage_count(hier)
    return total_count
end

---@param hier string Hierarchical path of the target module
function CoverageGetter:get_total_bin_expr_count(hier)
    local _, total_bin_expr_count = self:get_coverage_count(hier)
    return total_bin_expr_count
end

---@param hier_or_module string Hierarchical path of the target module or module name
---@param recursive boolean? Whether to reset coverage recursively
function CoverageGetter:reset_coverage(hier_or_module, recursive)
    if hier_or_module:find("%.") then
        -- Is hier path, because it contains "."
        self.setDpiScope(hier_or_module)
        self.resetCoverage()
    else
        -- Is module name
        if not self.cov_meta_info then
            self:read_cov_meta_info()
        end

        local hier_paths = self.cov_meta_info.exportedModules[hier_or_module].hierPaths
        if not hier_paths then
            assert(false, "[CoverageGetter] Failed to get hier paths from module name: " .. hier_or_module)
        end

        for _, hier_path in ipairs(hier_paths) do
            self.setDpiScope(hier_path)
            self.resetCoverage()
        end

        if recursive then
            for _, sub_module_name in ipairs(self.cov_meta_info.exportedModules[hier_or_module].subModules) do
                self:reset_coverage(sub_module_name, true)
            end
        end
    end
end

return CoverageGetter
