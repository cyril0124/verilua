local json = require "json"
local stringx = require "pl.stringx"
local SymbolHelper = require "SymbolHelper"

local cfg = _G.cfg
local f = string.format

---@class (exact) DpiExporter.meta_info
---@field cmdLine string
---@field configFileContent string
---@field dpiFilePath string
---@field exportedSignals string[]
---@field filelist string[]
---@field insertModuleName string
---@field topModuleName string

---@class (exact) DpiExporter
---@field private initialized boolean
---@field private meta_info DpiExporter.meta_info
---@field private dpi_exporter_top string
---@field private symbol_cache_idx number
---@field private symbol_cache table<number, function>
---@field init fun(self: DpiExporter, meta_file?: string): DpiExporter `meta_file` is a json file generated by `dpi_exporter`
---@field try_init fun(self: DpiExporter, meta_file?: string): boolean Try to initialize the exporter, return true if success
---@field is_exported fun(self: DpiExporter, hierpath: string): boolean, string
---@field fetch_trigger_func fun(self: DpiExporter): fun(): boolean
---@field fetch_get_value_func fun(self: DpiExporter, hierpath: string): fun(): number
---@field fetch_get64_value_func fun(self: DpiExporter, hierpath: string): fun(): number
---@field fetch_get_vec_value_func fun(self: DpiExporter, hierpath: string): function
---@field fetch_get_hex_str_value_func fun(self: DpiExporter, hierpath: string): function
local DpiExporter = {
    initialized = false,
    ---@diagnostic disable-next-line: missing-fields
    meta_info = {},
    dpi_exporter_top = "",
    symbol_cache_idx = 0,
    symbol_cache = {},
}

local function to_hierpath_name(hierpath)
    local t = stringx.replace(hierpath, ".", "_")
    t = stringx.replace(t, "[", "_")
    t = stringx.replace(t, "]", "_")
    return t
end

local function try_ffi_cast(type_str, type_str_ffi, value)
    if SymbolHelper.get_global_symbol_addr(value) ~= 0 then
        return SymbolHelper.ffi_cast(type_str, value)
    else
        ffi.cdef(type_str_ffi)
        assert(ffi.C[value], "[DpiExporter] Failed to get symbol: " .. type_str_ffi)
        return ffi.C[value]
    end
end

-- Auto detect meta_file
---@return string
local function try_get_meta_file()
    if SymbolHelper.get_global_symbol_addr("dpi_exporter_get_meta_info_file_path") ~= 0 then
        local func = SymbolHelper.ffi_cast("char *(*)()", "dpi_exporter_get_meta_info_file_path")
        local meta_file = ffi.string(func())
        return meta_file
    else
        ffi.cdef("char *dpi_exporter_get_meta_info_file_path();")
        assert(
            ffi.C.dpi_exporter_get_meta_info_file_path,
            "[DpiExporter] [try_get_meta_file] Failed to get symbol: dpi_exporter_get_meta_info_file_path"
        )
        return ffi.string(ffi.C.dpi_exporter_get_meta_info_file_path())
    end
end

function DpiExporter:init(meta_file)
    if self.initialized then
        return self
    end

    if not meta_file then
        meta_file = try_get_meta_file()
    end

    local file = io.open(meta_file, "r")
    if not file then
        error("[DpiExporter] Failed to open meta file: " .. meta_file)
    else
        self.meta_info = json.decode(file:read("*a"))
        assert(self.meta_info, "[DpiExporter] Failed to decode meta file: " .. meta_file)
        file:close()
    end

    -- Check if the dpi function file exists
    local dpi_func_file = self.meta_info.dpiFilePath
    local file2 = io.open(dpi_func_file, "r")
    if not file2 then
        error("[DpiExporter] Failed to open dpi function file: " .. dpi_func_file)
    else
        file2:close()
    end

    self.dpi_exporter_top = assert(
        self.meta_info.topModuleName,
        "[DpiExporter] Failed to get top module name from meta file: " .. meta_file
    )
    self.initialized = true

    -- Mark as enabled
    cfg.enable_dpi_exporter = true

    return self
end

function DpiExporter:try_init(meta_file)
    if not meta_file then
        meta_file = try_get_meta_file()
    end

    local file = io.open(meta_file, "r")
    if not file then
        return false
    else
        file:close()
        self:init(meta_file)
        return true
    end
end

function DpiExporter:is_exported(hierpath)
    assert(self.initialized, "DpiExporter not initialized")

    for _, signal_hierpath in ipairs(self.meta_info.exportedSignals) do
        -- Add `@` to make the hierpath unique
        local tmp = stringx.replace(
            "@" .. signal_hierpath,
            "@" .. self.dpi_exporter_top,
            cfg.top .. ".u_" .. self.dpi_exporter_top
        )
        if tmp == hierpath or hierpath == signal_hierpath then
            return true, signal_hierpath
        end
    end

    return false, ""
end

function DpiExporter:fetch_trigger_func()
    local func = try_ffi_cast(
        "bool (*)()",
        "bool dpi_exporter_sensitive_trigger();",
        "dpi_exporter_sensitive_trigger"
    ) --[[@as fun(): boolean]]
    self.symbol_cache_idx = self.symbol_cache_idx + 1
    self.symbol_cache[self.symbol_cache_idx] = func -- Keep the function alive(avoid gc)

    return self.symbol_cache[self.symbol_cache_idx]
end

function DpiExporter:fetch_get_value_func(hierpath)
    local is_exported, signal_hierpath = self:is_exported(hierpath)
    if not is_exported then
        assert(false, "[DpiExporter] Signal " .. hierpath .. " is not exported")
    end

    local func_name = f("VERILUA_DPI_EXPORTER_%s_GET", to_hierpath_name(signal_hierpath))
    local func = try_ffi_cast(
        "uint32_t (*)()",
        f("uint32_t %s();", func_name),
        func_name
    ) --[[@as function]]
    self.symbol_cache_idx = self.symbol_cache_idx + 1
    self.symbol_cache[self.symbol_cache_idx] = func -- Keep the function alive(avoid gc)

    return self.symbol_cache[self.symbol_cache_idx]
end

function DpiExporter:fetch_get64_value_func(hierpath)
    local is_exported, signal_hierpath = self:is_exported(hierpath)
    if not is_exported then
        assert(false, "[DpiExporter] Signal " .. hierpath .. " is not exported")
    end

    local func_name = f("VERILUA_DPI_EXPORTER_%s_GET64", to_hierpath_name(signal_hierpath))
    local func = try_ffi_cast(
        "uint64_t (*)()",
        f("uint64_t %s();", func_name),
        func_name
    ) --[[@as function]]
    self.symbol_cache_idx = self.symbol_cache_idx + 1
    self.symbol_cache[self.symbol_cache_idx] = func -- Keep the function alive(avoid gc)

    return self.symbol_cache[self.symbol_cache_idx]
end

function DpiExporter:fetch_get_vec_value_func(hierpath)
    local is_exported, signal_hierpath = self:is_exported(hierpath)
    if not is_exported then
        assert(false, "[DpiExporter] Signal " .. hierpath .. " is not exported")
    end

    local func_name = f("VERILUA_DPI_EXPORTER_%s_GET_VEC", to_hierpath_name(signal_hierpath))
    local func = try_ffi_cast(
        "void (*)(uint32_t *)",
        f("void %s(uint32_t *vec);", func_name),
        func_name
    ) --[[@as function]]
    self.symbol_cache_idx = self.symbol_cache_idx + 1
    self.symbol_cache[self.symbol_cache_idx] = func -- Keep the function alive(avoid gc)

    return self.symbol_cache[self.symbol_cache_idx]
end

function DpiExporter:fetch_get_hex_str_value_func(hierpath)
    local is_exported, signal_hierpath = self:is_exported(hierpath)
    if not is_exported then
        assert(false, "[DpiExporter] Signal " .. hierpath .. " is not exported")
    end

    local func_name = f("VERILUA_DPI_EXPORTER_%s_GET_HEX_STR", to_hierpath_name(signal_hierpath))
    local func = try_ffi_cast(
        "void (*)(char *)",
        f("void %s(char *hex_str);", func_name),
        func_name
    ) --[[@as function]]
    self.symbol_cache_idx = self.symbol_cache_idx + 1
    self.symbol_cache[self.symbol_cache_idx] = func -- Keep the function alive(avoid gc)

    return self.symbol_cache[self.symbol_cache_idx]
end

return DpiExporter
