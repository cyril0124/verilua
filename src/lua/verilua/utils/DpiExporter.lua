---@diagnostic disable: unnecessary-assert

local json = require "json"
local stringx = require "pl.stringx"
local SymbolHelper = require "verilua.utils.SymbolHelper"

local cfg = _G.cfg
local f = string.format

---@class (exact) verilua.utils.DpiExporter.meta_info
---@field cmdLine string
---@field configFileContent string
---@field dpiFilePath string
---@field exportedSignals string[]
---@field filelist string[]
---@field insertModuleName string
---@field topModuleName string

---@class (exact) verilua.utils.DpiExporter
---@field private initialized boolean
---@field private meta_info verilua.utils.DpiExporter.meta_info
---@field private dpi_exporter_top string
---@field private symbol_cache_idx number
---@field private symbol_cache table<number, function>
---@field init fun(self: verilua.utils.DpiExporter, meta_file?: string): verilua.utils.DpiExporter `meta_file` is a json file generated by `dpi_exporter`
---@field try_init fun(self: verilua.utils.DpiExporter, meta_file?: string): boolean Try to initialize the exporter, return true if success
---@field is_exported fun(self: verilua.utils.DpiExporter, hierpath: string): boolean, string
---@field fetch_trigger_func fun(self: verilua.utils.DpiExporter, trigger_name: string?): fun(): boolean
---@field fetch_get_value_func fun(self: verilua.utils.DpiExporter, hierpath: string): fun(): number
---@field fetch_get64_value_func fun(self: verilua.utils.DpiExporter, hierpath: string): fun(): number
---@field fetch_get_vec_value_func fun(self: verilua.utils.DpiExporter, hierpath: string): function
---@field fetch_get_hex_str_value_func fun(self: verilua.utils.DpiExporter, hierpath: string): function
local DpiExporter = {
    initialized = false,
    ---@diagnostic disable-next-line: missing-fields
    meta_info = {},
    dpi_exporter_top = "",
    symbol_cache_idx = 0,
    symbol_cache = {},
}

local function to_hierpath_name(hierpath)
    local t = stringx.replace(hierpath, ".", "_")
    t = stringx.replace(t, "[", "_")
    t = stringx.replace(t, "]", "_")
    return t
end

-- Auto detect meta_file
---@return string
local function try_get_meta_file()
    if SymbolHelper.get_global_symbol_addr("dpi_exporter_get_meta_info_file_path") ~= 0 then
        local func = SymbolHelper.ffi_cast("char *(*)()", "dpi_exporter_get_meta_info_file_path")
        local meta_file = ffi.string(func())
        return meta_file
    else
        ffi.cdef("char *dpi_exporter_get_meta_info_file_path();")
        assert(
            ffi.C.dpi_exporter_get_meta_info_file_path,
            "[DpiExporter] [try_get_meta_file] Failed to get symbol: dpi_exporter_get_meta_info_file_path"
        )
        return ffi.string(ffi.C.dpi_exporter_get_meta_info_file_path())
    end
end

function DpiExporter:init(meta_file)
    if self.initialized then
        return self
    end

    if not meta_file then
        meta_file = try_get_meta_file()
    end

    local file = io.open(meta_file, "r")
    if not file then
        error("[DpiExporter] Failed to open meta file: " .. meta_file)
    else
        self.meta_info = json.decode(file:read("*a"))
        assert(self.meta_info, "[DpiExporter] Failed to decode meta file: " .. meta_file)
        file:close()
    end

    -- Check if the dpi function file exists
    local dpi_func_file = self.meta_info.dpiFilePath
    local file2 = io.open(dpi_func_file, "r")
    if not file2 then
        error("[DpiExporter] Failed to open dpi function file: " .. dpi_func_file)
    else
        file2:close()
    end

    self.dpi_exporter_top = assert(
        self.meta_info.topModuleName,
        "[DpiExporter] Failed to get top module name from meta file: " .. meta_file
    )
    self.initialized = true

    -- Mark as enabled, used by `LuaCallableHDL.lua`
    -- Notice: Call `DpiExporter:init()` before creating any `CallableHDL` if you want to access the signal by dpi_exporter API.
    cfg.enable_dpi_exporter = true

    return self
end

function DpiExporter:try_init(meta_file)
    if not meta_file then
        meta_file = try_get_meta_file()
    end

    local file = io.open(meta_file, "r")
    if not file then
        return false
    else
        file:close()
        self:init(meta_file)
        return true
    end
end

function DpiExporter:is_exported(hierpath)
    assert(self.initialized, "DpiExporter not initialized")

    for _, signal_hierpath in ipairs(self.meta_info.exportedSignals) do
        -- Add `@` to make the hierpath unique
        local tmp = stringx.replace(
            "@" .. signal_hierpath,
            "@" .. self.dpi_exporter_top,
            cfg.top .. ".u_" .. self.dpi_exporter_top
        )
        if tmp == hierpath or hierpath == signal_hierpath then
            return true, signal_hierpath
        end
    end

    return false, ""
end

function DpiExporter:fetch_trigger_func(trigger_name)
    local trigger_func_name = "dpi_exporter_sensitive_trigger"
    if trigger_name then
        trigger_func_name = "dpi_exporter_sensitive_trigger_" .. trigger_name
    end
    local func = SymbolHelper.try_ffi_cast(
        "bool (*)()",
        f("bool %s();", trigger_func_name),
        trigger_func_name
    ) --[[@as fun(): boolean]]
    self.symbol_cache_idx = self.symbol_cache_idx + 1
    self.symbol_cache[self.symbol_cache_idx] = func -- Keep the function alive(avoid gc)

    return self.symbol_cache[self.symbol_cache_idx]
end

function DpiExporter:fetch_get_value_func(hierpath)
    local is_exported, signal_hierpath = self:is_exported(hierpath)
    if not is_exported then
        assert(false, "[DpiExporter] Signal " .. hierpath .. " is not exported")
    end

    local func_name = f("VERILUA_DPI_EXPORTER_%s_GET", to_hierpath_name(signal_hierpath))
    local func = SymbolHelper.try_ffi_cast(
        "uint32_t (*)()",
        f("uint32_t %s();", func_name),
        func_name
    ) --[[@as function]]
    self.symbol_cache_idx = self.symbol_cache_idx + 1
    self.symbol_cache[self.symbol_cache_idx] = func -- Keep the function alive(avoid gc)

    return self.symbol_cache[self.symbol_cache_idx]
end

function DpiExporter:fetch_get64_value_func(hierpath)
    local is_exported, signal_hierpath = self:is_exported(hierpath)
    if not is_exported then
        assert(false, "[DpiExporter] Signal " .. hierpath .. " is not exported")
    end

    local func_name = f("VERILUA_DPI_EXPORTER_%s_GET64", to_hierpath_name(signal_hierpath))
    local func = SymbolHelper.try_ffi_cast(
        "uint64_t (*)()",
        f("uint64_t %s();", func_name),
        func_name
    ) --[[@as function]]
    self.symbol_cache_idx = self.symbol_cache_idx + 1
    self.symbol_cache[self.symbol_cache_idx] = func -- Keep the function alive(avoid gc)

    return self.symbol_cache[self.symbol_cache_idx]
end

function DpiExporter:fetch_get_vec_value_func(hierpath)
    local is_exported, signal_hierpath = self:is_exported(hierpath)
    if not is_exported then
        assert(false, "[DpiExporter] Signal " .. hierpath .. " is not exported")
    end

    local func_name = f("VERILUA_DPI_EXPORTER_%s_GET_VEC", to_hierpath_name(signal_hierpath))
    local func = SymbolHelper.try_ffi_cast(
        "void (*)(uint32_t *)",
        f("void %s(uint32_t *vec);", func_name),
        func_name
    ) --[[@as function]]
    self.symbol_cache_idx = self.symbol_cache_idx + 1
    self.symbol_cache[self.symbol_cache_idx] = func -- Keep the function alive(avoid gc)

    return self.symbol_cache[self.symbol_cache_idx]
end

function DpiExporter:fetch_get_hex_str_value_func(hierpath)
    local is_exported, signal_hierpath = self:is_exported(hierpath)
    if not is_exported then
        assert(false, "[DpiExporter] Signal " .. hierpath .. " is not exported")
    end

    local func_name = f("VERILUA_DPI_EXPORTER_%s_GET_HEX_STR", to_hierpath_name(signal_hierpath))
    local func = SymbolHelper.try_ffi_cast(
        "void (*)(char *)",
        f("void %s(char *hex_str);", func_name),
        func_name
    ) --[[@as function]]
    self.symbol_cache_idx = self.symbol_cache_idx + 1
    self.symbol_cache[self.symbol_cache_idx] = func -- Keep the function alive(avoid gc)

    return self.symbol_cache[self.symbol_cache_idx]
end

return DpiExporter
