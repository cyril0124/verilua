local putils = require "pl.utils"
local texpect = require "TypeExpect"

local f = string.format

--- This module is used to generate type annotations used by lua language server like LuaLS/EmmyLua.
--- Mainly used for handles like `Bundle` and `AliasBundle` which use string literal to construct internal data
--- thus cannot be inferred by LuaLS/EmmyLua.
--- ```lua
---      local GenTypeAnno = require "GenTypeAnno"
---      GenTypeAnno:gen_type_anno {
---          filename = "path/to/yout/meta.lua",
---          handles = {
---              { "MyBundle", my_bundle },
---              { "MyAliasBundle", my_alias_bundle },
---              my_bundle_1,
---              my_alias_bundle_1,
---          }
---      }
---
---      -- After running the above code, you will get a file named "path/to/yout/meta.lua".
---      -- This file will be loaded by LuaLS/EmmyLua to provide type annotations for your handles.
---      -- To inject the generated type annotations into your project, you can add the following code to your code:
---      local my_bundle = <...> -- Definition of your bundle
---      ---@cast my_bundle +MyBundle
---
---      `---@cast` can be used in LuaLS/EmmyLua to inject type annotations into your variables.
---      After that, you are able to get type suggestions for your handles.
--- ```

---@class (exact) GenTypeAnno.bundle_seq
---@field [1] string name
---@field [2] Bundle|AliasBundle value

---@class (exact) GenTypeAnno.params
---@field filename string
---@field handles table<integer, Bundle|AliasBundle|GenTypeAnno.bundle_seq>

---@class (exact) GenTypeAnno
---@field gen_type_anno fun(self: GenTypeAnno, params: GenTypeAnno.params)
local GenTypeAnno = {}

local unique_name_map = {}
---@param name string
---@param bundle Bundle
---@return string
local function gen_type_anno_bundle(name, bundle)
    assert(not unique_name_map[name], "[gen_type_anno_bundle] Duplicate bundle name: " .. name)
    unique_name_map[name] = true

    local content_vec = {}
    if bundle.is_decoupled then
        local bits_content_vec = {
            f("---@class %s.bits", name),
        }
        for field_name, chdl in pairs(bundle.bits) do
            local hierpath = bundle.hierarchy .. "." .. bundle.prefix .. "bits_" .. field_name
            local width = chdl:get_width()
            bits_content_vec[#bits_content_vec + 1] = f(
                "---@field %s CallableHDL hierpath: %s width: %d",
                field_name,
                hierpath,
                width
            )
        end

        content_vec[#content_vec + 1] = table.concat(bits_content_vec, "\n")
        content_vec[#content_vec + 1] = ""
        content_vec[#content_vec + 1] = f("---@class %s", name)
        content_vec[#content_vec + 1] = f("---@field bits %s.bits", name)
    else
        content_vec[1] = f("---@class %s", name)
        for _, field_name in ipairs(bundle.signals_table) do
            local hierpath = bundle.hierarchy .. "." .. bundle.prefix .. field_name
            local width = bundle[field_name]:get_width()
            content_vec[#content_vec + 1] = f(
                "---@field %s CallableHDL hierpath: %s width: %d",
                field_name,
                hierpath,
                width
            )
        end
    end

    return table.concat(content_vec, "\n")
end

---@param name string
---@param alias_bundle AliasBundle
---@return string
local function gen_type_anno_alias_bundle(name, alias_bundle)
    assert(not unique_name_map[name], "[gen_type_anno_bundle] Duplicate alias_bundle name: " .. name)
    unique_name_map[name] = true

    local content_vec = {
        f("---@class %s", name)
    }
    for i, field_name in ipairs(alias_bundle.alias_tbl) do
        local hierpath = alias_bundle.hierarchy .. "." .. alias_bundle.prefix .. alias_bundle.signals_tbl[i]
        local width = alias_bundle[field_name]:get_width()
        content_vec[#content_vec + 1] = f(
            "---@field %s CallableHDL hierpath: %s width: %d",
            field_name,
            hierpath,
            width
        )
    end

    return table.concat(content_vec, "\n")
end

function GenTypeAnno:gen_type_anno(params)
    texpect.expect_table(params, "params")
    texpect.expect_string(params.filename, "params.filename")

    local content_vec = {
        "---@meta",
        "--------------------------------------------------------------------",
        "-- This file is generated by GenTypeAnno. Do not modify it manually!",
        "--------------------------------------------------------------------",
        "",
    }
    for i, handle in ipairs(params.handles) do
        texpect.expect_table(handle, "params.handles[" .. i .. "]")
        if not handle.__type then
            local name = handle[1]
            local value = handle[2]
            texpect.expect_string(name, "params.handles[" .. i .. "][1]")
            texpect.expect_table(value, "params.handles[" .. i .. "][2]")
            if value.__type == "Bundle" then
                ---@cast value Bundle
                content_vec[#content_vec + 1] = gen_type_anno_bundle(name, value)
            elseif value.__type == "AliasBundle" then
                ---@cast value AliasBundle
                content_vec[#content_vec + 1] = gen_type_anno_alias_bundle(name, value)
            else
                assert(false, "params.handles[" .. i .. "][2]" .. " is not a `Bundle` or `AliasBundle`")
            end
        else
            if handle.__type == "Bundle" then
                ---@cast handle Bundle
                content_vec[#content_vec + 1] = gen_type_anno_bundle(handle.name, handle)
            elseif handle.__type == "AliasBundle" then
                ---@cast handle AliasBundle
                content_vec[#content_vec + 1] = gen_type_anno_alias_bundle(handle.name, handle)
            else
                assert(false, "params.handles[" .. i .. "]" .. " is not a `Bundle` or `AliasBundle`")
            end
        end

        content_vec[#content_vec + 1] = "\n"
    end

    putils.writefile(params.filename, table.concat(content_vec, "\n"))
end

return GenTypeAnno
