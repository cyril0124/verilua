#pragma once

#include "SemanticModel.h"
#include "SlangCommon.h"
#include "fmt/base.h"
#include "fmt/color.h"
#include "inja/inja.hpp"
#include "libassert/assert.hpp"
#include "slang/ast/ASTVisitor.h"
#include "slang/ast/Compilation.h"
#include "slang/ast/Symbol.h"
#include "slang/driver/Driver.h"
#include "slang/syntax/AllSyntax.h"
#include "slang/syntax/SyntaxPrinter.h"
#include "slang/syntax/SyntaxTree.h"
#include "slang/util/Util.h"
#include "sol/sol.hpp"
#include <cstddef>
#include <cstdio>
#include <filesystem>
#include <fmt/ranges.h>
#include <fstream>
#include <memory>
#include <nlohmann/json.hpp>
#include <regex>
#include <span>
#include <string>
#include <unordered_set>
#include <vector>

// ===========================================================
// Optimization configs
// ===========================================================
// #define NO_STD_COPY

#define DEFAULT_OUTPUT_DIR ".dpi_exporter"
#define DEFAULT_WORK_DIR ".dpi_exporter"
#define DEFAULT_DPI_FILE_NAME "dpi_func.cpp"
#define DEFAULT_CLOCK_NAME "clock"
#define DEFAULT_SAMPLE_EDGE "negedge"

#define ANSI_COLOR_RED "\x1b[31m"
#define ANSI_COLOR_YELLOW "\x1b[33m"
#define ANSI_COLOR_MAGENTA "\x1b[35m"
#define ANSI_COLOR_GREEN "\x1b[32m"
#define ANSI_COLOR_RESET "\x1b[0m"

#define DELETE_FILE(filePath)                                                                                                                                                                                                                                                                                                                                                                                  \
    do {                                                                                                                                                                                                                                                                                                                                                                                                       \
        if (std::filesystem::exists(filePath)) {                                                                                                                                                                                                                                                                                                                                                               \
            std::filesystem::remove(filePath);                                                                                                                                                                                                                                                                                                                                                                 \
        }                                                                                                                                                                                                                                                                                                                                                                                                      \
    } while (0)

inline const char *getDpiFileTemplate() {
    return R"(
// ------------------------------------------------------------
// Auto generated by `dpi_exporter`
// DO NOT MODIFY THIS FILE!
// ------------------------------------------------------------
#include <svdpi.h>
#include <stdint.h>
#include <stdio.h>
#include <string>
#include <unordered_map>
#include <algorithm>
#include <functional>

using GetValue32Func = std::function<uint32_t ()>;
using GetValueVecFunc = std::function<void (uint32_t *)>;
using GetValueHexStrFunc = std::function<void (char*)>;

using SetValue32Func = std::function<void (uint32_t)>;
using SetValueVecFunc = std::function<void (uint32_t *)>;
using SetValueHexStrFunc = std::function<void (char*)>;

{{dpiFuncFileContent}}

extern "C" int64_t dpi_exporter_handle_by_name(std::string name) {
    static std::unordered_map<std::string, int64_t> name_to_handle = {
{{handleByName}}
    };

    auto it = name_to_handle.find(name);
    if (it != name_to_handle.end()) {
        return it->second;
    } else {
        return -1;
    }
}

extern "C" std::string dpi_exporter_get_type_str(int64_t handle) {
    static std::unordered_map<int64_t, std::string> handle_to_type_str = {
{{getTypeStr}}
    };

    auto it = handle_to_type_str.find(handle);
    if (it != handle_to_type_str.end()) {
        return std::string(it->second);
    } else {
        return std::string("");
    }
}

extern "C" uint32_t dpi_exporter_get_bitwidth(int64_t handle) {
    static std::unordered_map<int64_t, uint32_t> handle_to_bitwidth = {
{{getBitWidth}}
    };

    auto it = handle_to_bitwidth.find(handle);
    if (it != handle_to_bitwidth.end()) {
        return it->second;
    } else {
        return 0;
    }
}

extern "C" GetValue32Func dpi_exporter_alloc_get_value32(int64_t handle) {
    static std::unordered_map<int64_t, GetValue32Func> handle_to_func = {
{{getValue32}}
    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" GetValueVecFunc dpi_exporter_alloc_get_value_vec(int64_t handle) {
    static std::unordered_map<int64_t, GetValueVecFunc> handle_to_func = {
{{getValueVec}}
    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" GetValueHexStrFunc dpi_exporter_alloc_get_value_hex_str(int64_t handle) {
    static std::unordered_map<int64_t, GetValueHexStrFunc> handle_to_func = {
{{getValueHexStr}}
    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" SetValue32Func dpi_exporter_alloc_set_value32(int64_t handle) {
    static std::unordered_map<int64_t, SetValue32Func> handle_to_func = {
{{setValue32}}
    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" SetValueVecFunc dpi_exporter_alloc_set_value_vec(int64_t handle) {
    static std::unordered_map<int64_t, SetValueVecFunc> handle_to_func = {
{{setValueVec}}
    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" SetValueHexStrFunc dpi_exporter_alloc_set_value_hex_str(int64_t handle) {
    static std::unordered_map<int64_t, SetValueHexStrFunc> handle_to_func = {
{{setValueHexStr}}
    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" char *dpi_exporter_get_top_name() {
    static char top_name[] = "{{topModuleName}}";
    return top_name;
}

extern "C" char *dpi_exporter_get_meta_info_file_path() {
    static char meta_info_file_path[] = "{{metaInfoFilePath}}";
    return meta_info_file_path;
}

## if distributeDPI == 0

// Call verilua_main_step_safe() in dpi_exporter_tick() if `DPI_EXP_CALL_VERILUA_ENV_STEP` macro is defined.
// Only available when `distributeDPI` is 0.
#ifdef DPI_EXP_CALL_VERILUA_ENV_STEP
extern "C" void verilua_main_step_safe();
#endif // DPI_EXP_CALL_VERILUA_ENV_STEP

extern "C" void dpi_exporter_tick({{dpiTickFuncParam}}) {
{{dpiTickFuncBody}}

#ifdef DPI_EXP_CALL_VERILUA_ENV_STEP
    verilua_main_step_safe();
#endif // DPI_EXP_CALL_VERILUA_ENV_STEP
}
## endif
)";
}

inline std::vector<std::string> parseFileList(const std::string &filePath) {
    std::vector<std::string> files;
    std::ifstream infile(filePath);
    std::string line;

    while (std::getline(infile, line)) {
        if (!line.empty()) {
            files.push_back(line);
        }
    }

    return files;
}

inline sol::object getLuaTableItemOrFailed(sol::table &table, const std::string &key) {
    sol::object obj = table[key];
    if (obj.get_type() == sol::type::nil) {
        throw std::runtime_error("[logic_fuzzer] (nil) Failed to get lua table entry: " + key);
    }
    return obj;
}

inline uint32_t coverWith32(uint32_t size) { return (size + 31) / 32; }
inline uint32_t coverWith4(uint32_t size) { return (size + 3) / 4; }

inline uint32_t log2Ceil(uint32_t x) {
    if (x == 0) {
        PANIC("log2Ceil(0)");
    }
    return std::ceil(std::log2(x));
}

using PortInfo = struct {
    std::string name;
    std::string direction;
    bitwidth_t bitWidth;
    uint64_t handleId;
    bool writable;
    std::string typeStr;
    std::string hierPathName;
    std::string hierPathNameDot;
};

using DPIExporterInfo = struct {
    std::string moduleName;
    std::string clock;
    std::vector<std::string> signalPatternVec;
    std::vector<std::string> writableSignalPatternVec;
    std::vector<std::string> disableSignalPatternVec;
    bool isTopModule;
};

class HierPathGetter : public ASTVisitor<HierPathGetter, false, false> {
  public:
    std::string moduleName;
    std::string instName;

  public:
    std::vector<std::string> hierPaths;

    HierPathGetter(std::string moduleName, std::string instName) : moduleName(moduleName), instName(instName) {}

    void handle(const InstanceSymbol &inst) {
        auto _moduleName = inst.getDefinition().name;
        auto _instName   = inst.name;

        if (_instName == instName && _moduleName == moduleName) {
            std::string hierPath = "";
            inst.getHierarchicalPath(hierPath);
            // fmt::println("[HierPathGetter] moduleName:<{}> instName:<{}> hierPath:<{}>", _moduleName, _instName, hierPath);

            hierPaths.emplace_back(hierPath);
        } else {
            visitDefault(inst);
        }
    }
};