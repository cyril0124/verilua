#include "render_dpi_file.h"
#include "dpi_exporter.h"

using json = nlohmann::json;

inline static const char *getDpiFileTemplate() {
    return R"(
// ------------------------------------------------------------
// Auto generated by `dpi_exporter`
// DO NOT MODIFY THIS FILE!
// ------------------------------------------------------------
#include <svdpi.h>
#include <stdint.h>
#include <stdio.h>
#include <string>
#include <unordered_map>
#include <algorithm>
#include <functional>
#include <cassert>

using GetValue32Func = std::function<uint32_t ()>;
using GetValueVecFunc = std::function<void (uint32_t *)>;
using GetValueHexStrFunc = std::function<void (char*)>;

using SetValue32Func = std::function<void (uint32_t)>;
using SetValueVecFunc = std::function<void (uint32_t *)>;
using SetValueHexStrFunc = std::function<void (char*)>;

{{dpiFuncFileContent}}

extern "C" int64_t dpi_exporter_handle_by_name(std::string name) {
    static std::unordered_map<std::string, int64_t> name_to_handle = {
{{handleByName}}
    };

    auto it = name_to_handle.find(name);
    if (it != name_to_handle.end()) {
        return it->second;
    } else {
        return -1;
    }
}

extern "C" std::string dpi_exporter_get_type_str(int64_t handle) {
    static std::unordered_map<int64_t, std::string> handle_to_type_str = {
{{getTypeStr}}
    };

    auto it = handle_to_type_str.find(handle);
    if (it != handle_to_type_str.end()) {
        return std::string(it->second);
    } else {
        return std::string("");
    }
}

extern "C" uint32_t dpi_exporter_get_bitwidth(int64_t handle) {
    static std::unordered_map<int64_t, uint32_t> handle_to_bitwidth = {
{{getBitWidth}}
    };

    auto it = handle_to_bitwidth.find(handle);
    if (it != handle_to_bitwidth.end()) {
        return it->second;
    } else {
        return 0;
    }
}

extern "C" GetValue32Func dpi_exporter_alloc_get_value32(int64_t handle) {
    static std::unordered_map<int64_t, GetValue32Func> handle_to_func = {
{{getValue32}}
    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" GetValueVecFunc dpi_exporter_alloc_get_value_vec(int64_t handle) {
    static std::unordered_map<int64_t, GetValueVecFunc> handle_to_func = {
{{getValueVec}}
    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" GetValueHexStrFunc dpi_exporter_alloc_get_value_hex_str(int64_t handle) {
    static std::unordered_map<int64_t, GetValueHexStrFunc> handle_to_func = {
{{getValueHexStr}}
    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" SetValue32Func dpi_exporter_alloc_set_value32(int64_t handle) {
    static std::unordered_map<int64_t, SetValue32Func> handle_to_func = {
{{setValue32}}
    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" SetValueVecFunc dpi_exporter_alloc_set_value_vec(int64_t handle) {
    static std::unordered_map<int64_t, SetValueVecFunc> handle_to_func = {
{{setValueVec}}
    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" SetValueHexStrFunc dpi_exporter_alloc_set_value_hex_str(int64_t handle) {
    static std::unordered_map<int64_t, SetValueHexStrFunc> handle_to_func = {
{{setValueHexStr}}
    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" char *dpi_exporter_get_top_name() {
    static char top_name[] = "{{topModuleName}}";
    return top_name;
}

extern "C" char *dpi_exporter_get_meta_info_file_path() {
    static char meta_info_file_path[] = "{{metaInfoFilePath}}";
    return meta_info_file_path;
}

{% if distributeDPI == 0 %}

// Call verilua_main_step_safe() in dpi_exporter_tick() if `DPI_EXP_CALL_VERILUA_ENV_STEP` macro is defined.
// Only available when `distributeDPI` is 0.
#ifdef DPI_EXP_CALL_VERILUA_ENV_STEP

// The `DPI_EXP_USE_STRICT_STEP` macro controls error handling semantics for the Verilua step
// invoked from the simulator:
// - If `DPI_EXP_USE_STRICT_STEP` is defined, `verilua_main_step()` is used. In strict mode,
//   any uncaught Lua error will cause an immediate termination of the whole simulation. Use this
//   when you prefer fail-fast semantics and want simulation to stop on script errors.
// - If `DPI_EXP_USE_STRICT_STEP` is NOT defined, `verilua_main_step_safe()` is used. In safe
//   mode, Lua errors are caught/reported and the simulator continues running. Use this when you
//   need resilience to scripting errors and prefer the simulator to keep running.
#ifdef DPI_EXP_USE_STRICT_STEP
extern "C" void verilua_main_step();
#else // DPI_EXP_USE_STRICT_STEP
extern "C" void verilua_main_step_safe();
#endif // DPI_EXP_USE_STRICT_STEP

{% if hasSensitiveSignals == 1 %}
bool hasSignalChanged = false; // Used for sensitive signals to indicate if there is a change in all sensitive signals.
{{otherTriggerVars}}
{% endif %}
#endif // DPI_EXP_CALL_VERILUA_ENV_STEP

extern "C" void dpi_exporter_tick({{dpiTickFuncParam}}) {
{{dpiTickFuncBody}}

#ifdef DPI_EXP_CALL_VERILUA_ENV_STEP

#ifdef DPI_EXP_USE_STRICT_STEP
    verilua_main_step();
#else // DPI_EXP_USE_STRICT_STEP
    verilua_main_step_safe();
#endif // DPI_EXP_USE_STRICT_STEP

{% if hasSensitiveSignals == 1 %}
    hasSignalChanged = false;
    {{otherTriggerVarsReset}}
{% endif %}
#endif // DPI_EXP_CALL_VERILUA_ENV_STEP
}

{{sDpiTickFuncContent}}

{{sDpiTriggerFuncContent}}

{% endif %} {# `if distributeDPI == 0` #}
)";
}

std::string renderDpiFile(std::vector<SignalGroup> &signalGroupVec, std::vector<SensitiveTriggerInfo> &sensitiveTriggerInfoVec, std::string topModuleName, bool distributeDPI, std::string metaInfoFilePath) {
    bool hasSensitiveSignals = false;
    std::vector<std::string> handleByNameVec;
    std::vector<std::string> getTypeStrVec;
    std::vector<std::string> getBitWidthVec;

    std::vector<std::string> getValue32Vec;
    std::vector<std::string> getValueVecVec;
    std::vector<std::string> getValueHexStrVec;

    std::vector<std::string> setValue32Vec;
    std::vector<std::string> setValueVecVec;
    std::vector<std::string> setValueHexStrVec;

    std::vector<std::string> dpiSignalBlockVec;
    std::vector<std::string> dpiTickFuncParamVec;
    std::vector<std::string> dpiTickFuncBodyVec;

    std::unordered_map<std::string, std::vector<std::string>> sDpiTickFuncParamMap;
    std::unordered_map<std::string, std::vector<std::string>> sDpiTickFuncBodyMap;

    std::vector<std::string> otherTriggerVarsVec;
    std::vector<std::string> otherTriggerVarsResetVec;
    for (auto &st : sensitiveTriggerInfoVec) {
        otherTriggerVarsVec.push_back(fmt::format("bool hasSignalChanged_{} = false;", st.name));
        otherTriggerVarsResetVec.push_back(fmt::format("hasSignalChanged_{} = false;", st.name));
    }

    // Reserve space for the vectors.
    for (auto &sg : signalGroupVec) {
        if (sg.sensitiveSignalInfoVec.empty()) {
            continue;
        }
        sDpiTickFuncParamMap[sg.name] = {};
        sDpiTickFuncBodyMap[sg.name]  = {};
        hasSensitiveSignals           = true;
    }

    for (auto &sg : signalGroupVec) {
        auto hasSensitiveSignals = !sg.sensitiveSignalInfoVec.empty();

        for (auto &s : sg.signalInfoVec) {
            std::string extraInfo = fmt::format("/* hierPath: {} bitWidth: {} handleId: {} */", s.hierPath, s.bitWidth, s.handleId);
            handleByNameVec.push_back(fmt::format("\t\t{{ \"{}\", {} }} {}", s.hierPathName, s.handleId, extraInfo));
            getTypeStrVec.push_back(fmt::format("\t\t{{ {}, \"{}\" }} {}", s.handleId, s.vpiTypeStr, extraInfo));
            getBitWidthVec.push_back(fmt::format("\t\t{{ {}, {} }} {}", s.handleId, s.bitWidth, extraInfo));

            getValue32Vec.push_back(fmt::format("\t\t{{ {}, VERILUA_DPI_EXPORTER_{}_GET }} {}", s.handleId, s.hierPathName, extraInfo));
            if (s.bitWidth > 32) {
                getValueVecVec.push_back(fmt::format("\t\t{{ {}, VERILUA_DPI_EXPORTER_{}_GET_VEC }} {}", s.handleId, s.hierPathName, extraInfo));
            }
            getValueHexStrVec.push_back(fmt::format("\t\t{{ {}, VERILUA_DPI_EXPORTER_{}_GET_HEX_STR }} {}", s.handleId, s.hierPathName, extraInfo));

            if (s.isWritable) {
                setValue32Vec.push_back(fmt::format("\t\t{{ {}, VERILUA_DPI_EXPORTER_{}_SET }} {}", s.handleId, s.hierPathName, extraInfo));
                if (s.bitWidth > 32) {
                    setValueVecVec.push_back(fmt::format("\t\t{{ {}, VERILUA_DPI_EXPORTER_{}_SET_VEC }} {}", s.handleId, s.hierPathName, extraInfo));
                }
                setValueHexStrVec.push_back(fmt::format("\t\t{{ {}, VERILUA_DPI_EXPORTER_{}_SET_HEX_STR }} {}", s.handleId, s.hierPathName, extraInfo));
            }

            static auto insertInfo = [](std::vector<std::string> &paramVec, std::vector<std::string> &bodyVec, SignalInfo &s) {
                if (s.bitWidth == 1) {
                    if (s.isWritable) {
                        paramVec.push_back(fmt::format("uint8_t *{}", s.hierPathName));
                    } else {
                        paramVec.push_back(fmt::format("const uint8_t {}", s.hierPathName));
                    }
                } else {
                    if (s.isWritable) {
                        paramVec.push_back(fmt::format("uint32_t *{}", s.hierPathName));
                    } else {
                        paramVec.push_back(fmt::format("const uint32_t *{}", s.hierPathName));
                    }
                }

                if (s.beatSize == 1) {
                    if (s.bitWidth == 1) {
                        if (s.isWritable) {
                            bodyVec.push_back(fmt::format("\t*{} = __{};", s.hierPathName, s.hierPathName));
                        } else {
                            bodyVec.push_back(fmt::format("\t__{} = {};", s.hierPathName, s.hierPathName));
                        }
                    } else {
                        if (s.isWritable) {
                            bodyVec.push_back(fmt::format("\t*{} = __{};", s.hierPathName, s.hierPathName));
                        } else {
                            bodyVec.push_back(fmt::format("\t__{} = *{};", s.hierPathName, s.hierPathName));
                        }
                    }
                } else {
                    if (s.isWritable) {
                        bodyVec.push_back(fmt::format("\tstd::copy(__{0}, __{0} + {1}, {0});", s.hierPathName, s.beatSize));
                    } else {
                        bodyVec.push_back(fmt::format("\tstd::copy({0}, {0} + {1}, __{0});", s.hierPathName, s.beatSize));
                    }
                }
            };

            if (!hasSensitiveSignals) {
                // If the signal group has no sensitive signals, we can directly insert the signal info into default DPI tick function.
                insertInfo(dpiTickFuncParamVec, dpiTickFuncBodyVec, s);
            } else {
                // If the signal group has sensitive signals, we insert the signal info into the corresponding DPI tick function.
                insertInfo(sDpiTickFuncParamMap[sg.name], sDpiTickFuncBodyMap[sg.name], s);
            }
        }

        std::string dpiSignalDecl = "";
        std::vector<std::string> dpiSignalAccessFunctionsVec;
        for (auto &s : sg.signalInfoVec) {
            std::string extraInfo = fmt::format("/* hierPath: {} bitWidth: {} handleId: {} */", s.hierPath, s.bitWidth, s.handleId);

            if (s.beatSize == 1) {
                if (s.bitWidth == 1) {
                    dpiSignalDecl.append(fmt::format("uint8_t __{}; {}\n", s.hierPathName, extraInfo));
                } else {
                    dpiSignalDecl.append(fmt::format("uint32_t __{}; {}\n", s.hierPathName, extraInfo));
                }
            } else {
                dpiSignalDecl.append(fmt::format("uint32_t __{}[{}]; {}\n", s.hierPathName, s.beatSize, extraInfo));
            }

            // Generate reader functions
            if (s.beatSize == 1) {
                dpiSignalAccessFunctionsVec.push_back(fmt::format(R"(
extern "C" uint32_t VERILUA_DPI_EXPORTER_{0}_GET() {{
    return (uint32_t)__{0};
}})",
                                                                  s.hierPathName));

                dpiSignalAccessFunctionsVec.push_back(fmt::format(R"(
extern "C" uint64_t VERILUA_DPI_EXPORTER_{0}_GET64() {{
    return (uint64_t)__{0};
}})",
                                                                  s.hierPathName));

                dpiSignalAccessFunctionsVec.push_back(fmt::format(R"(
extern "C" void VERILUA_DPI_EXPORTER_{0}_GET_HEX_STR(char *hexStr) {{
    uint32_t value = __{0};
    for(int i = {1}; i >= 0; --i) {{
        hexStr[i] = "0123456789abcdef"[value & 0xF];
        value >>= 4;
    }}
    hexStr[{2}] = '\0';
}})",
                                                                  s.hierPathName, coverWith4(s.bitWidth) - 1, coverWith4(s.bitWidth)));
            } else { // beatSize > 1
                dpiSignalAccessFunctionsVec.push_back(fmt::format(R"(
extern "C" uint32_t VERILUA_DPI_EXPORTER_{0}_GET() {{
    return (uint32_t)__{0}[0];
}})",
                                                                  s.hierPathName));
                dpiSignalAccessFunctionsVec.push_back(fmt::format(R"(
extern "C" uint64_t VERILUA_DPI_EXPORTER_{0}_GET64() {{
    return (uint64_t)((uint64_t)(__{0}[1]) << 32 | (uint64_t)__{0}[0]);
}})",
                                                                  s.hierPathName));

                std::string tmp = fmt::format("\tstd::copy(__{0}, __{0} + {1}, values);\n", s.hierPathName, s.beatSize);
                dpiSignalAccessFunctionsVec.push_back(fmt::format(R"(
extern "C" void VERILUA_DPI_EXPORTER_{}_GET_VEC(uint32_t *values) {{
{}
}})",
                                                                  s.hierPathName, tmp));

                if (s.beatSize == 2) {
                    dpiSignalAccessFunctionsVec.push_back(fmt::format(R"(
extern "C" void VERILUA_DPI_EXPORTER_{0}_GET_HEX_STR(char *hexStr) {{
    uint32_t value;
    value = __{0}[0];
    for(int i = 8 + {1} - 1; i >= {1}; --i) {{
        hexStr[i] = "0123456789abcdef"[value & 0xF];
        value >>= 4;
    }}
    
    value = __{0}[1];
    for(int i = {1} - 1; i >= 0; --i) {{
        hexStr[i] = "0123456789abcdef"[value & 0xF];
        value >>= 4;
    }}

    hexStr[{2}] = '\0';
}})",

                                                                      s.hierPathName, coverWith4(s.bitWidth) - 8, coverWith4(s.bitWidth)));
                } else { // beatSize > 2
                    std::string tmp = "";
                    int beatIdx     = 0;
                    for (int k = s.beatSize - 1; k >= 0; k--) {
                        tmp = tmp + fmt::format(R"(
    value = __{}[{}];
    for(int i = {}; i >= {}; --i) {{
        hexStr[i] = "0123456789abcdef"[value & 0xF];
        value >>= 4;
    }}
)",
                                                s.hierPathName, beatIdx, (k + 1) * 8 - 1, k * 8);
                        beatIdx++;
                    }
                    tmp.pop_back();

                    dpiSignalAccessFunctionsVec.push_back(fmt::format(R"(
extern "C" void VERILUA_DPI_EXPORTER_{}_GET_HEX_STR(char *hexStr) {{
    uint32_t value;
{}
    hexStr[{}] = '\0';
}})",
                                                                      s.hierPathName, tmp, coverWith4(s.bitWidth)));
                }
            }

            // Generate writer functions
            if (s.isWritable) {
                if (s.beatSize == 1) {
                    dpiSignalAccessFunctionsVec.push_back(fmt::format(R"(
extern "C" void VERILUA_DPI_EXPORTER_{0}_SET(uint32_t value) {{
    __{0} = value;
}})",
                                                                      s.hierPathName));
                    dpiSignalAccessFunctionsVec.push_back(fmt::format(R"(
extern "C" void VERILUA_DPI_EXPORTER_{0}_SET64(uint64_t value) {{
    __{0} = (uint32_t)value;
}})",
                                                                      s.hierPathName));
                    dpiSignalAccessFunctionsVec.push_back(fmt::format(R"(
extern "C" void VERILUA_DPI_EXPORTER_{0}_SET_HEX_STR(char *hexStr) {{
    uint32_t value = 0;
    for (int i = 0; hexStr[i] != '\0' && i < 7; ++i) {{
        char c = hexStr[i];
        value <<= 4;
        if (c >= '0' && c <= '9') {{
            value |= (c - '0');
        }} else if (c >= 'a' && c <= 'f') {{
            value |= (c - 'a' + 10);
        }} else if (c >= 'A' && c <= 'F') {{
            value |= (c - 'A' + 10);
        }}
    }}
    __{0} = value;
}})",
                                                                      s.hierPathName));

                } else { // beatSize > 1
                    dpiSignalAccessFunctionsVec.push_back(fmt::format(R"(
extern "C" void VERILUA_DPI_EXPORTER_{0}_SET(uint32_t value) {{
    __{0}[0] = value;
    for (int i = 1; i < {1}; i++) {{
        __{0}[i] = 0;
    }}
}})",
                                                                      s.hierPathName, s.beatSize));
                    dpiSignalAccessFunctionsVec.push_back(fmt::format(R"(
extern "C" void VERILUA_DPI_EXPORTER_{0}_SET64(uint64_t value) {{
    __{0}[0] = value & 0xFFFFFFFF;
    __{0}[1] = (uint32_t)(value >> 32);
    for (int i = 2; i < {1}; i++) {{
        __{0}[i] = 0;
    }}
}})",
                                                                      s.hierPathName, s.beatSize));
                    dpiSignalAccessFunctionsVec.push_back(fmt::format(R"(
extern "C" void VERILUA_DPI_EXPORTER_{0}_SET_VEC(uint32_t *values) {{
    std::copy(values, values + {1}, __{0});
}})",
                                                                      s.hierPathName, s.beatSize));
                    dpiSignalAccessFunctionsVec.push_back(fmt::format(R"(
extern "C" void VERILUA_DPI_EXPORTER_{0}_SET_HEX_STR(char *hexStr) {{
    for (int j = 0; j < {1}; j++) {{
        uint32_t value = 0;
        for (int i = j * 8; hexStr[i] != '\0' && i < 8 + j * 8; ++i) {{
            char c = hexStr[i];
            value <<= 4;
            if (c >= '0' && c <= '9') {{
                value |= (c - '0');
            }} else if (c >= 'a' && c <= 'f') {{
                value |= (c - 'a' + 10);
            }} else if (c >= 'A' && c <= 'F') {{
                value |= (c - 'A' + 10);
            }}
        }}
        __{0}[{1} - 1 - j] = value;
    }}
}})",
                                                                      s.hierPathName, s.beatSize));
                }
            }
        }

        json j;
        j["signalGroupName"]          = sg.name;
        j["dpiSignalDecl"]            = dpiSignalDecl;
        j["dpiSignalAccessFunctions"] = joinStrVec(dpiSignalAccessFunctionsVec, "\n");
        dpiSignalBlockVec.push_back(inja::render(R"(
// ------------------------------------------------------
// Signal group: {{signalGroupName}}
// ------------------------------------------------------
{{dpiSignalDecl}}
{{dpiSignalAccessFunctions}}


)",
                                                 j));
    }

    json j;
    j["topModuleName"]      = topModuleName;
    j["distributeDPI"]      = distributeDPI ? 1 : 0;
    j["dpiFuncFileContent"] = joinStrVec(dpiSignalBlockVec, "\n"); // dpiFuncFileContent;
    j["metaInfoFilePath"]   = metaInfoFilePath;
    j["handleByName"]       = joinStrVec(handleByNameVec, ",\n");
    j["getTypeStr"]         = joinStrVec(getTypeStrVec, ",\n");
    j["getBitWidth"]        = joinStrVec(getBitWidthVec, ",\n");
    j["getValue32"]         = joinStrVec(getValue32Vec, ",\n");
    j["getValueVec"]        = joinStrVec(getValueVecVec, ",\n");
    j["getValueHexStr"]     = joinStrVec(getValueHexStrVec, ",\n");
    j["setValue32"]         = joinStrVec(setValue32Vec, ",\n");
    j["setValueVec"]        = joinStrVec(setValueVecVec, ",\n");
    j["setValueHexStr"]     = joinStrVec(setValueHexStrVec, ",\n");
    j["dpiTickFuncParam"]   = joinStrVec(dpiTickFuncParamVec, ", ");
    j["dpiTickFuncBody"]    = joinStrVec(dpiTickFuncBodyVec, "\n");

    std::string sDpiTickFuncContent = "";
    for (auto &pair : sDpiTickFuncParamMap) {
        auto sgName        = pair.first;
        auto &funcParamVec = pair.second;

        std::vector<std::string> otherTriggerVarsSetVec;
        for (auto &st : sensitiveTriggerInfoVec) {
            if (std::find(st.groupNames.begin(), st.groupNames.end(), sgName) != st.groupNames.end()) {
                otherTriggerVarsSetVec.push_back(fmt::format("hasSignalChanged_{} = true;", st.name));
            }
        }

        sDpiTickFuncContent += fmt::format(R"(
extern "C" void dpi_exporter_tick_{0}({1}) {{
{2}

#ifdef DPI_EXP_CALL_VERILUA_ENV_STEP
    hasSignalChanged = true;
    {3}
#endif
}}
)",
                                           sgName, joinStrVec(funcParamVec, ", "), joinStrVec(sDpiTickFuncBodyMap[sgName], "\n"), joinStrVec(otherTriggerVarsSetVec, "\n"));
    }
    j["sDpiTickFuncContent"] = sDpiTickFuncContent;

    json jj;
    std::string sDpiTriggerFuncContent = "";
    jj["hasSensitiveSignals"]          = hasSensitiveSignals ? 1 : 0;
    sDpiTriggerFuncContent             = inja::render(R"(
// When sensitive signal groups are updated(i.e. dpi_exporter_tick_<SenstiveGroupName>), this function can be used to check whether any signal has changed.
// Normally used for optimizing the performance of obtaining signal values by reducing unnecessary signal value sampling actions.
extern "C" bool dpi_exporter_sensitive_trigger() {
#ifdef DPI_EXP_CALL_VERILUA_ENV_STEP
{% if hasSensitiveSignals == 1 %}
    return hasSignalChanged;
{% else %}
    assert(0 && "dpi_exporter_sensitive_trigger() should not be called when hasSensitiveSignals is FALSE");
{% endif %}
#else
    assert(0 && "dpi_exporter_sensitive_trigger() should not be called when cflags macro DPI_EXP_CALL_VERILUA_ENV_STEP is not defined");
#endif
}
)",
                                                      jj);

    for (auto &st : sensitiveTriggerInfoVec) {
        json jjj;
        jjj["triggerName"]         = st.name;
        jjj["hasSensitiveSignals"] = hasSensitiveSignals ? 1 : 0;

        sDpiTriggerFuncContent = sDpiTriggerFuncContent + "\n" +
                                 inja::render(R"(
extern "C" bool dpi_exporter_sensitive_trigger_{{triggerName}}() {
#ifdef DPI_EXP_CALL_VERILUA_ENV_STEP
{% if hasSensitiveSignals == 1 %}
    return hasSignalChanged_{{triggerName}};
{% else %}
    assert(0 && "dpi_exporter_sensitive_trigger_{{triggerName}}() should not be called when hasSensitiveSignals is FALSE");
{% endif %}
#else
    assert(0 && "dpi_exporter_sensitive_trigger_{{triggerName}}() should not be called when cflags macro DPI_EXP_CALL_VERILUA_ENV_STEP is not defined");
#endif
}
        )",
                                              jjj);
    }

    j["hasSensitiveSignals"]    = hasSensitiveSignals ? 1 : 0;
    j["otherTriggerVars"]       = joinStrVec(otherTriggerVarsVec, "\n");
    j["otherTriggerVarsReset"]  = joinStrVec(otherTriggerVarsResetVec, "\n");
    j["sDpiTriggerFuncContent"] = sDpiTriggerFuncContent;

    return inja::render(getDpiFileTemplate(), j);
}