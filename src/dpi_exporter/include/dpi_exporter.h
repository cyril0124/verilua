#pragma once

#include "SemanticModel.h"
#include "SlangCommon.h"
#include "config.h"
#include "fmt/base.h"
#include "fmt/color.h"
#include "inja/inja.hpp"
#include "libassert/assert.hpp"
#include "slang/ast/ASTVisitor.h"
#include "slang/ast/Compilation.h"
#include "slang/ast/Symbol.h"
#include "slang/driver/Driver.h"
#include "slang/syntax/AllSyntax.h"
#include "slang/syntax/SyntaxPrinter.h"
#include "slang/syntax/SyntaxTree.h"
#include "slang/util/Util.h"
#include "sol/sol.hpp"
#include <cstddef>
#include <cstdio>
#include <filesystem>
#include <fmt/ranges.h>
#include <fstream>
#include <memory>
#include <nlohmann/json.hpp>
#include <regex>
#include <span>
#include <string>
#include <unordered_set>
#include <vector>

#define DEFAULT_OUTPUT_DIR ".dpi_exporter"
#define DEFAULT_WORK_DIR ".dpi_exporter"
#define DEFAULT_DPI_FILE_NAME "dpi_func.cpp"
#define DEFAULT_CLOCK_NAME "clock"
#define DEFAULT_SAMPLE_EDGE "negedge"

#define ANSI_COLOR_RED "\x1b[31m"
#define ANSI_COLOR_YELLOW "\x1b[33m"
#define ANSI_COLOR_MAGENTA "\x1b[35m"
#define ANSI_COLOR_GREEN "\x1b[32m"
#define ANSI_COLOR_RESET "\x1b[0m"

#define DELETE_FILE(filePath)                                                                                                                                                                                                                                                                                                                                                                                  \
    do {                                                                                                                                                                                                                                                                                                                                                                                                       \
        if (std::filesystem::exists(filePath)) {                                                                                                                                                                                                                                                                                                                                                               \
            std::filesystem::remove(filePath);                                                                                                                                                                                                                                                                                                                                                                 \
        }                                                                                                                                                                                                                                                                                                                                                                                                      \
    } while (0)

inline const char *getDpiFileTemplate1() {
    return R"(
// ------------------------------------------------------------
// Auto generated by `dpi_exporter`
// DO NOT MODIFY THIS FILE!
// ------------------------------------------------------------
#include <svdpi.h>
#include <stdint.h>
#include <stdio.h>
#include <string>
#include <unordered_map>
#include <algorithm>
#include <functional>

using GetValue32Func = std::function<uint32_t ()>;
using GetValueVecFunc = std::function<void (uint32_t *)>;
using GetValueHexStrFunc = std::function<void (char*)>;

using SetValue32Func = std::function<void (uint32_t)>;
using SetValueVecFunc = std::function<void (uint32_t *)>;
using SetValueHexStrFunc = std::function<void (char*)>;

{{dpiFuncFileContent}}

extern "C" int64_t dpi_exporter_handle_by_name(std::string name) {
    static std::unordered_map<std::string, int64_t> name_to_handle = {
{{handleByName}}
    };

    auto it = name_to_handle.find(name);
    if (it != name_to_handle.end()) {
        return it->second;
    } else {
        return -1;
    }
}

extern "C" std::string dpi_exporter_get_type_str(int64_t handle) {
    static std::unordered_map<int64_t, std::string> handle_to_type_str = {
{{getTypeStr}}
    };

    auto it = handle_to_type_str.find(handle);
    if (it != handle_to_type_str.end()) {
        return std::string(it->second);
    } else {
        return std::string("");
    }
}

extern "C" uint32_t dpi_exporter_get_bitwidth(int64_t handle) {
    static std::unordered_map<int64_t, uint32_t> handle_to_bitwidth = {
{{getBitWidth}}
    };

    auto it = handle_to_bitwidth.find(handle);
    if (it != handle_to_bitwidth.end()) {
        return it->second;
    } else {
        return 0;
    }
}

extern "C" GetValue32Func dpi_exporter_alloc_get_value32(int64_t handle) {
    static std::unordered_map<int64_t, GetValue32Func> handle_to_func = {
{{getValue32}}
    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" GetValueVecFunc dpi_exporter_alloc_get_value_vec(int64_t handle) {
    static std::unordered_map<int64_t, GetValueVecFunc> handle_to_func = {
{{getValueVec}}
    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" GetValueHexStrFunc dpi_exporter_alloc_get_value_hex_str(int64_t handle) {
    static std::unordered_map<int64_t, GetValueHexStrFunc> handle_to_func = {
{{getValueHexStr}}
    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" SetValue32Func dpi_exporter_alloc_set_value32(int64_t handle) {
    static std::unordered_map<int64_t, SetValue32Func> handle_to_func = {
{{setValue32}}
    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" SetValueVecFunc dpi_exporter_alloc_set_value_vec(int64_t handle) {
    static std::unordered_map<int64_t, SetValueVecFunc> handle_to_func = {
{{setValueVec}}
    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" SetValueHexStrFunc dpi_exporter_alloc_set_value_hex_str(int64_t handle) {
    static std::unordered_map<int64_t, SetValueHexStrFunc> handle_to_func = {
{{setValueHexStr}}
    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" char *dpi_exporter_get_top_name() {
    static char top_name[] = "{{topModuleName}}";
    return top_name;
}

extern "C" char *dpi_exporter_get_meta_info_file_path() {
    static char meta_info_file_path[] = "{{metaInfoFilePath}}";
    return meta_info_file_path;
}

## if distributeDPI == 0

// Call verilua_main_step_safe() in dpi_exporter_tick() if `DPI_EXP_CALL_VERILUA_ENV_STEP` macro is defined.
// Only available when `distributeDPI` is 0.
#ifdef DPI_EXP_CALL_VERILUA_ENV_STEP
extern "C" void verilua_main_step_safe();
#endif // DPI_EXP_CALL_VERILUA_ENV_STEP

extern "C" void dpi_exporter_tick({{dpiTickFuncParam}}) {
{{dpiTickFuncBody}}

#ifdef DPI_EXP_CALL_VERILUA_ENV_STEP
    verilua_main_step_safe();
#endif // DPI_EXP_CALL_VERILUA_ENV_STEP
}
## endif
)";
}

inline std::vector<std::string> parseFileList(const std::string &filePath) {
    std::vector<std::string> files;
    std::ifstream infile(filePath);
    std::string line;

    while (std::getline(infile, line)) {
        if (!line.empty()) {
            files.push_back(line);
        }
    }

    return files;
}

inline sol::object getLuaTableItemOrFailed(sol::table &table, const std::string &key) {
    sol::object obj = table[key];
    if (obj.get_type() == sol::type::nil) {
        throw std::runtime_error("[logic_fuzzer] (nil) Failed to get lua table entry: " + key);
    }
    return obj;
}

inline uint32_t coverWith32(uint32_t size) { return (size + 31) / 32; }
inline uint32_t coverWith4(uint32_t size) { return (size + 3) / 4; }

inline uint32_t log2Ceil(uint32_t x) {
    if (x == 0) {
        PANIC("log2Ceil(0)");
    }
    return std::ceil(std::log2(x));
}

inline std::pair<std::string, std::string> spiltHierPath(const std::string &hierPath) {
    auto dotPos = hierPath.rfind('.');
    ASSERT(dotPos != std::string::npos, "Invalid hierPath", hierPath);

    auto modulePath = hierPath.substr(0, dotPos);
    auto signalName = hierPath.substr(dotPos + 1);
    return std::make_pair(modulePath, signalName);
}

struct ConciseSignalPattern {
    std::string name;
    std::string module;
    std::string clock;
    std::string signals;
    std::string writableSignals;
    std::string disableSignals;
    std::string sensitiveSignals;

    bool checkValidSignal(std::string_view signal) { return checkValidSignal(std::string(signal)); }

    bool checkValidSignal(std::string signal) {
        // Check invalid signal
        if (!disableSignals.empty()) {
            std::regex disablePattern(disableSignals);
            if (std::regex_match(signal, disablePattern)) {
                return false;
            }
        }

        if (signals.empty()) {
            return checkWritableSignal(signal);
        }

        std::regex signalPattern(signals);
        if (std::regex_match(signal, signalPattern)) {
            return true;
        }

        return checkWritableSignal(signal);
    }

    bool checkWritableSignal(std::string_view signal) { return checkWritableSignal(std::string(signal)); }

    bool checkWritableSignal(std::string signal) {
        if (writableSignals.empty()) {
            return false;
        }

        std::regex signalPattern(writableSignals);
        if (std::regex_match(signal, signalPattern)) {
            return true;
        }

        return false;
    }
};

struct SignalInfo {
    std::string hierPath;
    std::string modulePath;
    std::string signalName;
    std::string vpiTypeStr;
    bitwidth_t bitWidth;
    uint64_t handleId;
    bool isWritable;

    std::string hierPathName;
    size_t beatSize;
    SignalInfo(std::string hierPath, std::string modulePath, std::string signalName, std::string vpiTypeStr, bitwidth_t bitWidth, uint64_t handleId, bool isWritable) : hierPath(hierPath), modulePath(modulePath), signalName(signalName), vpiTypeStr(vpiTypeStr), bitWidth(bitWidth), handleId(handleId), isWritable(isWritable) {
        hierPathName = getHierPathName();
        beatSize     = coverWith32(bitWidth);
    }

    std::string getHierPathName() {
        std::string hierPathName = hierPath;
        std::replace(hierPathName.begin(), hierPathName.end(), '.', '_');
        return hierPathName;
    }
};

struct SignalGroup {
    std::string name;
    std::string moduleName;
    ConciseSignalPattern cpattern;
    std::vector<SignalInfo> signalInfoVec;
};

inline uint64_t getUniqueHandleId() {
    static uint64_t handleId = 0;
    return handleId++;
}

inline std::vector<std::string> getHierPaths(slang::ast::Compilation &compilation, std::string moduleName) {
    struct HierPathGetter : public slang::ast::ASTVisitor<HierPathGetter, false, false> {
        std::string moduleName;
        std::vector<std::string> hierPaths;
        HierPathGetter(std::string moduleName) : moduleName(moduleName) {}

        void handle(const InstanceSymbol &inst) {
            auto _moduleName = inst.getDefinition().name;

            if (_moduleName == moduleName) {
                // Hierarchical path may come from multiple instances
                std::string hierPath = "";
                inst.getHierarchicalPath(hierPath);
                hierPaths.emplace_back(hierPath);
            } else {
                visitDefault(inst);
            }
        }
    };

    HierPathGetter visitor(moduleName);
    compilation.getRoot().visit(visitor);
    return visitor.hierPaths;
}

inline std::vector<std::string> getHierPaths(slang::ast::Compilation *compilation, std::string moduleName) { return getHierPaths(*compilation, moduleName); }

inline std::vector<std::string> getHierPaths(slang::ast::Compilation *compilation, std::string_view moduleName) { return getHierPaths(*compilation, std::string(moduleName)); }

inline bool checkUniqueSignal(std::string signal) {
    static std::unordered_set<std::string> signalSet;

    if (signalSet.count(signal) != 0) {
        return false;
    }
    signalSet.insert(signal);
    return true;
}