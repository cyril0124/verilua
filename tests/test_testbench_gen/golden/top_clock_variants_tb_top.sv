
//VCS coverage exclude_file
// -----------------------------------------
// test bench generated by VERILUA
// -----------------------------------------

// -----------------------------------------
// user custom code
//    use `--custom-code-outer/-cco <file>` to pass in the custom code file.
//       |_ e.g. `testbench_gen [...] --custom-code-outer path/to/file`
//    use `--custom-code-str-outer/-ccso <string>` to pass in the custom code string.
//       |_ e.g. `testbench_gen [...] --custom-code-str-outer "`define a 1"`
// -----------------------------------------




module tb_top (
`ifdef SIM_VERILATOR
    input wire clock,
    input wire reset,
    output wire [63:0] cycles_o
`endif // SIM_VERILATOR
);


// -----------------------------------------
// macro define check
// -----------------------------------------
`ifdef SIM_VERILATOR
  `ifdef SIM_VCS
    initial begin
      $error("Both SIM_VERILATOR and SIM_VCS are defined. Only one should be defined.");
      $finish;
    end
  `endif
  `ifdef SIM_XCELIUM
    initial begin
      $error("Both SIM_VERILATOR and SIM_XCELIUM are defined. Only one should be defined.");
      $finish;
    end
  `endif
`else
  `ifndef SIM_VCS
    `ifndef SIM_IVERILOG
      `ifndef SIM_XCELIUM
        initial begin
          $error("One of [SIM_VERILATOR / SIM_VCS / SIM_IVERILOG / SIM_XCELIUM] is not defined! One must be defined.");
          $finish;
        end
      `endif
    `endif
  `endif
`endif


// -----------------------------------------
// deal with clock, reset, cycles
// -----------------------------------------
`ifndef SIM_VERILATOR
reg sys_clk;
reg sys_rst_n;

initial begin
    sys_clk = 0;
    sys_rst_n = 1;
end

`ifndef NO_INTERNAL_CLOCK
always #10.0 sys_clk = ~sys_clk;
`endif // NO_INTERNAL_CLOCK
`endif // SIM_VERILATOR


`ifdef SIM_VERILATOR
wire sys_clk;
assign sys_clk = clock;
`else // SIM_VERILATOR
wire clock;
assign clock = sys_clk;
`endif // SIM_VERILATOR



`ifdef SIM_VERILATOR
wire sys_rst_n;
assign sys_rst_n = reset;
`else // SIM_VERILATOR
wire reset;
assign reset = sys_rst_n;
`endif // SIM_VERILATOR



reg [63:0] cycles; // A timestamp counter for simulation, start from 0 and never reset

initial cycles = 0;
always@(posedge sys_clk) begin
    cycles <= cycles + 1; // Increment the timestamp counter every clock cycle
end

`ifdef SIM_VERILATOR
assign cycles_o = cycles; // Tie the timestamp counter to the output port for verilator
`endif

// -----------------------------------------
// reg/wire declaration
// -----------------------------------------
reg i_clock; // input wire i_clock
reg clk_core; // input wire clk_core
reg main_clock; // input wire main_clock
reg i_reset; // input wire i_reset
reg rst_core; // input wire rst_core
reg main_reset_n; // input wire main_reset_n
reg [7:0] data_in; // input wire [7:0] data_in
wire [7:0] data_out; // output reg [7:0] data_out


// -----------------------------------------
//  reg initialize
// -----------------------------------------
initial begin
    // $display("[INFO] @%0t [%s:%d] hello from tb_top", $time, `__FILE__, `__LINE__);
	i_clock = 0;
	clk_core = 0;
	main_clock = 0;
	i_reset = 0;
	rst_core = 0;
	main_reset_n = 0;
	data_in = 0;
end

// -----------------------------------------
//  DUT module instantiate
// -----------------------------------------
TopClockVariants  u_TopClockVariants (
	.sys_clk                        (sys_clk                       ) /* direction: input      dataType: wire */,
	.i_clock                        (i_clock                       ) /* direction: input      dataType: wire */,
	.clk_core                       (clk_core                      ) /* direction: input      dataType: wire */,
	.main_clock                     (main_clock                    ) /* direction: input      dataType: wire */,
	.sys_rst_n                      (sys_rst_n                     ) /* direction: input      dataType: wire */,
	.i_reset                        (i_reset                       ) /* direction: input      dataType: wire */,
	.rst_core                       (rst_core                      ) /* direction: input      dataType: wire */,
	.main_reset_n                   (main_reset_n                  ) /* direction: input      dataType: wire */,
	.data_in                        (data_in                       ) /* direction: input      dataType: wire  [7:0] */,
	.data_out                       (data_out                      ) /* direction: output     dataType:  reg [7:0] */
); // u_TopClockVariants


// -----------------------------------------
// tracing functions
// https://github.com/chipsalliance/chisel/blob/main/svsim/src/main/scala/Workspace.scala
// -----------------------------------------
`ifndef SIM_IVERILOG
    export "DPI-C" function simulation_initializeTrace;
    export "DPI-C" function simulation_enableTrace;
    export "DPI-C" function simulation_disableTrace;

    function void simulation_initializeTrace;
        input string traceFilePath;

        `ifdef SIM_VERILATOR
            $display("[INFO] @%0t [%s:%d] simulation_initializeTrace trace type => VCD", $time, `__FILE__, `__LINE__);
            $dumpfile(traceFilePath);
            $dumpvars(0, tb_top);
        `endif // SIM_VERILATOR

        `ifdef SIM_VCS
            `ifdef VCS_DUMP_VCD
                $display("[INFO] @%0t [%s:%d] simulation_initializeTrace trace type => VCD", $time, `__FILE__, `__LINE__);
                $dumpfile(traceFilePath);
                $dumpvars(0, tb_top);
            `else // VCS_DUMP_VCD
                $display("[INFO] @%0t [%s:%d] simulation_initializeTrace trace type => FSDB", $time, `__FILE__, `__LINE__);

                `ifdef FSDB_AUTO_SWITCH
                    `ifndef FILE_SIZE
                        `define FILE_SIZE 25
                    `endif

                    `ifndef NUM_OF_FILES
                        `define NUM_OF_FILES 1000
                    `endif

                    $fsdbAutoSwitchDumpfile(`FILE_SIZE, {traceFilePath, ".fsdb"}, `NUM_OF_FILES);
                `else // FSDB_AUTO_SWITCH
                    $fsdbDumpfile({traceFilePath, ".fsdb"});
                `endif // FSDB_AUTO_SWITCH

                `ifdef FSDB_DUMP_SVA
                    //
                    // Dump System Verilog Assertions
                    // Notice: To enable this feature, you also need to add `+fsdb+sva_success`
                    //         to your `./simv` command line args at runtime or in your `vcs`
                    //         command line args at build time.
                    //
                    $fsdbDumpSVA(0, tb_top);
                `endif // FSDB_DUMP_SVA

                //
                // $fsdbDumpvars([depth, instance][, "option"]);
                // options:
                //   +all: Record all signals, including memories, MDA (Memory Data Array), packed arrays, structures, etc.
                //   +mda: Record all memory and MDA signals. MDA (Memory Data Array) signals refer to those related to memory data arrays.
                //   +IO_Only: Record only input and output port signals.
                //   +Reg_Only: Record only signals of register type.
                //   +parameter: Record parameters.
                //   +fsdbfile+filename: Specify the fsdb file name.
                //
                $fsdbDumpvars(0, tb_top, "+all");
            `endif // VCS_DUMP_VCD
        `endif // SIM_VCS

        `ifdef SIM_XCELIUM
            `ifdef XCELIUM_DUMP_VCD
                $display("[INFO] @%0t [%s:%d] simulation_initializeTrace trace type => VCD", $time, `__FILE__, `__LINE__);
                $dumpfile(traceFilePath);
                $dumpvars(0, tb_top);
            `elsif XCELIUM_DUMP_FSDB
                $display("[INFO] @%0t [%s:%d] simulation_initializeTrace trace type => FSDB", $time, `__FILE__, `__LINE__);

                `ifdef FSDB_AUTO_SWITCH
                    `ifndef FILE_SIZE
                        `define FILE_SIZE 25
                    `endif

                    `ifndef NUM_OF_FILES
                        `define NUM_OF_FILES 1000
                    `endif

                    $fsdbAutoSwitchDumpfile(`FILE_SIZE, {traceFilePath, ".fsdb"}, `NUM_OF_FILES);
                `else // FSDB_AUTO_SWITCH
                    $fsdbDumpfile({traceFilePath, ".fsdb"});
                `endif // FSDB_AUTO_SWITCH

                `ifdef FSDB_DUMP_SVA
                    $fsdbDumpSVA(0, tb_top);
                `endif // FSDB_DUMP_SVA

                $fsdbDumpvars(0, tb_top, "+all");
            `else // Default to SHM for XCELIUM
                $display("[INFO] @%0t [%s:%d] simulation_initializeTrace trace type => SHM", $time, `__FILE__, `__LINE__);

                // Notice: $shm_open cannot accept string variable as the input file name.
                //          e.g. $shm_open({traceFilePath, ".shm"});
                $shm_open("waves.shm");

                $shm_probe(tb_top, "AS");
            `endif // XCELIUM_DUMP_VCD
        `endif // SIM_XCELIUM
    endfunction

    function void simulation_enableTrace;
        `ifdef SIM_VERILATOR
            $display("[INFO] @%0t [%s:%d] simulation_enableTrace trace type => VCD", $time, `__FILE__, `__LINE__);
            $dumpon;
        `endif

        `ifdef SIM_VCS
            `ifdef VCS_DUMP_VCD
                $display("[INFO] @%0t [%s:%d] simulation_enableTrace trace type => VCD", $time, `__FILE__, `__LINE__);
                $dumpon;
            `else // VCS_DUMP_VCD
                $display("[INFO] @%0t [%s:%d] simulation_enableTrace trace type => FSDB", $time, `__FILE__, `__LINE__);
                $fsdbDumpon;
                // $fsdbDumpMDA(); // enable dump Multi-Dimension-Array
            `endif // VCS_DUMP_VCD
        `endif

        `ifdef SIM_XCELIUM
            `ifdef XCELIUM_DUMP_VCD
                $display("[INFO] @%0t [%s:%d] simulation_enableTrace trace type => VCD", $time, `__FILE__, `__LINE__);
                $dumpon;
            `elsif XCELIUM_DUMP_FSDB
                $display("[INFO] @%0t [%s:%d] simulation_enableTrace trace type => FSDB", $time, `__FILE__, `__LINE__);
                $fsdbDumpon;
            `else // Default to SHM for XCELIUM
                $display("[INFO] @%0t [%s:%d] simulation_enableTrace trace type => SHM", $time, `__FILE__, `__LINE__);
                // SHM tracing is enabled by default when $shm_probe is called
            `endif // XCELIUM_DUMP_VCD
        `endif // SIM_XCELIUM
    endfunction

    function void simulation_disableTrace;
        `ifdef SIM_VERILATOR
            $display("[INFO] @%0t [%s:%d] simulation_disableTrace trace type => VCD", $time, `__FILE__, `__LINE__);
            $dumpoff;
        `endif

        `ifdef SIM_VCS
            `ifdef VCS_DUMP_VCD
                $display("[INFO] @%0t [%s:%d] simulation_disableTrace trace type => VCD", $time, `__FILE__, `__LINE__);
                $dumpoff;
            `else // VCS_DUMP_VCD
                $display("[INFO] @%0t [%s:%d] simulation_disableTrace trace type => FSDB", $time, `__FILE__, `__LINE__);
                $fsdbDumpoff;
            `endif // VCS_DUMP_VCD
        `endif

        `ifdef SIM_XCELIUM
            `ifdef XCELIUM_DUMP_VCD
                $display("[INFO] @%0t [%s:%d] simulation_disableTrace trace type => VCD", $time, `__FILE__, `__LINE__);
                $dumpoff;
            `elsif XCELIUM_DUMP_FSDB
                $display("[INFO] @%0t [%s:%d] simulation_disableTrace trace type => FSDB", $time, `__FILE__, `__LINE__);
                $fsdbDumpoff;
            `else // Default to SHM for XCELIUM
                $display("[INFO] @%0t [%s:%d] simulation_disableTrace trace type => SHM", $time, `__FILE__, `__LINE__);
                $shm_close;
            `endif // XCELIUM_DUMP_VCD
        `endif // SIM_XCELIUM
    endfunction
`endif // SIM_IVERILOG

`ifdef SIM_IVERILOG
reg simulation_initializeTrace;
reg simulation_initializeTrace_latch;

reg simulation_enableTrace;
reg simulation_enableTrace_latch;

reg simulation_disableTrace;
reg simulation_disableTrace_latch;

initial begin
    simulation_initializeTrace = 0;
    simulation_initializeTrace_latch = 0;

    simulation_enableTrace = 0;
    simulation_enableTrace_latch = 0;

    simulation_disableTrace = 0;
    simulation_disableTrace_latch = 0;
end

always@(posedge sys_clk or negedge sys_clk) begin
    if(simulation_initializeTrace && !simulation_initializeTrace_latch) begin
        integer file;
        string trace_name = "dump.vcd";
        file = $fopen("iverilog_trace_name.txt", "r");
        $fscanf(file, "%s", trace_name);
        $fclose(file);

        $display("[INFO] @%0t [%s:%d] simulation_initializeTrace trace type => VCD", $time, `__FILE__, `__LINE__);
        $dumpfile(trace_name);
        $dumpvars(0, tb_top);

        simulation_initializeTrace_latch <= 1;
    end

    if(simulation_enableTrace && !simulation_enableTrace_latch) begin
        $display("[INFO] @%0t [%s:%d] simulation_enableTrace trace type => VCD", $time, `__FILE__, `__LINE__);
        $dumpon;

        simulation_enableTrace_latch <= 1;
    end

    if(simulation_disableTrace && !simulation_disableTrace_latch) begin
        $display("[INFO] @%0t [%s:%d] simulation_disableTrace trace type => VCD", $time, `__FILE__, `__LINE__);
        $dumpoff;

        simulation_disableTrace_latch <= 1;
    end
end
`endif // SIM_IVERILOG


// -----------------------------------------
// tracing command interface
// -----------------------------------------
`ifdef SIM_VCS
initial begin
    string dump_file = "dump";
    integer dump_start_cycle = 0;

    if ($test$plusargs("dump_enable=1")) begin
        // 1. set dump file name
        // +dump_file=<file_name>
        if ($value$plusargs("dump_file=%s", dump_file))
            $display("[INFO] @%0t [%s:%d] dump_file => %s ", $time, `__FILE__, `__LINE__, dump_file);
        else
            $display("[INFO] @%0t [%s:%d] [default] dump_file => %s ", $time, `__FILE__, `__LINE__, dump_file);

        // 2. set dump start cycle
        // +dump_start_cycle=<cycle_number>
        if ($value$plusargs("dump_start_cycle=%d", dump_start_cycle))
            $display("[INFO] @%0t [%s:%d] dump_start_cycle: %d ", $time, `__FILE__, `__LINE__, dump_start_cycle);

        // 3. set dump type
        // +dump_vcd
        if ($test$plusargs("dump_vcd")) begin
            $display("[INFO] @%0t [%s:%d] enable dump_vcd ", $time, `__FILE__, `__LINE__);

            repeat(dump_start_cycle) @(posedge sys_clk);
            $display("[INFO] @%0t [%s:%d] start dump_vcd at cycle => %d... ", $time, `__FILE__, `__LINE__, dump_start_cycle);

            $dumpfile({dump_file, ".vcd"});
            $dumpvars(0, tb_top);
        // +dump_fsdb
        end else if ($test$plusargs("dump_fsdb")) begin
            `ifndef VCS_DUMP_VCD
                $display("[INFO] @%0t [%s:%d] enable dump_fsdb ", $time, `__FILE__, `__LINE__);

                repeat(dump_start_cycle) @(posedge sys_clk);
                $display("[INFO] @%0t [%s:%d] start dump_fsdb at cycle => %d... ", $time, `__FILE__, `__LINE__, dump_start_cycle);
                $fsdbDumpfile({dump_file, ".fsdb"});
                $fsdbDumpvars(0, tb_top);
            `else // VCS_DUMP_VCD
                $error("VCS_DUMP_VCD is defined, but dump_fsdb is requested. Please check your configuration.");
            `endif // VCS_DUMP_VCD
        end else begin
            $display("[ERROR] @%0t [%s:%d] neither dump_vcd or dump_fsdb are not pass in", $time, `__FILE__, `__LINE__);
            $fatal;
        end
    end
end
`endif // SIM_VCS


// -----------------------------------------
// other user code...
// -----------------------------------------
Others u_others(
  .clock(sys_clk),
  .reset(sys_rst_n)
);


// -----------------------------------------
// user custom code
//    use `--custom-code/-cc <file>` to pass in the custom code file.
//       |_ e.g. `testbench_gen [...] --custom-code path/to/file`
//    use `--custom-code-str/-ccs <string>` to pass in the custom code string.
//       |_ e.g. `testbench_gen [...] --custom-code-str "reg a; initial a = 1;"`
// -----------------------------------------






endmodule
