
// ------------------------------------------------------------
// Auto generated by `dpi_exporter`
// DO NOT MODIFY THIS FILE!
// ------------------------------------------------------------
#include <svdpi.h>
#include <stdint.h>
#include <stdio.h>
#include <string>
#include <unordered_map>
#include <algorithm>
#include <functional>
#include <cassert>

using GetValue32Func = std::function<uint32_t ()>;
using GetValueVecFunc = std::function<void (uint32_t *)>;
using GetValueHexStrFunc = std::function<void (char*)>;

using SetValue32Func = std::function<void (uint32_t)>;
using SetValueVecFunc = std::function<void (uint32_t *)>;
using SetValueHexStrFunc = std::function<void (char*)>;


// ------------------------------------------------------
// Signal group: DEFAULT
// ------------------------------------------------------






// ------------------------------------------------------
// Signal group: o_signals
// ------------------------------------------------------
uint8_t __top_b_inst_valid1; /* hierPath: top.b_inst.valid1 bitWidth: 1 handleId: 0 */
uint8_t __top_b_inst_o_value_0; /* hierPath: top.b_inst.o_value_0 bitWidth: 1 handleId: 1 */
uint8_t __top_b_inst_o_value_1; /* hierPath: top.b_inst.o_value_1 bitWidth: 1 handleId: 2 */
uint8_t __top_b_inst_o_value_2; /* hierPath: top.b_inst.o_value_2 bitWidth: 1 handleId: 3 */
uint8_t __top_b_inst_o_value_4; /* hierPath: top.b_inst.o_value_4 bitWidth: 1 handleId: 4 */
uint8_t __top_b_inst_o_value_5; /* hierPath: top.b_inst.o_value_5 bitWidth: 1 handleId: 5 */
uint8_t __top_b_inst_o_value_6; /* hierPath: top.b_inst.o_value_6 bitWidth: 1 handleId: 6 */


extern "C" uint32_t VERILUA_DPI_EXPORTER_top_b_inst_valid1_GET() {
    return (uint32_t)__top_b_inst_valid1;
}

extern "C" uint64_t VERILUA_DPI_EXPORTER_top_b_inst_valid1_GET64() {
    return (uint64_t)__top_b_inst_valid1;
}

extern "C" void VERILUA_DPI_EXPORTER_top_b_inst_valid1_GET_HEX_STR(char *hexStr) {
    uint32_t value = __top_b_inst_valid1;
    for(int i = 0; i >= 0; --i) {
        hexStr[i] = "0123456789abcdef"[value & 0xF];
        value >>= 4;
    }
    hexStr[1] = '\0';
}

extern "C" uint32_t VERILUA_DPI_EXPORTER_top_b_inst_o_value_0_GET() {
    return (uint32_t)__top_b_inst_o_value_0;
}

extern "C" uint64_t VERILUA_DPI_EXPORTER_top_b_inst_o_value_0_GET64() {
    return (uint64_t)__top_b_inst_o_value_0;
}

extern "C" void VERILUA_DPI_EXPORTER_top_b_inst_o_value_0_GET_HEX_STR(char *hexStr) {
    uint32_t value = __top_b_inst_o_value_0;
    for(int i = 0; i >= 0; --i) {
        hexStr[i] = "0123456789abcdef"[value & 0xF];
        value >>= 4;
    }
    hexStr[1] = '\0';
}

extern "C" uint32_t VERILUA_DPI_EXPORTER_top_b_inst_o_value_1_GET() {
    return (uint32_t)__top_b_inst_o_value_1;
}

extern "C" uint64_t VERILUA_DPI_EXPORTER_top_b_inst_o_value_1_GET64() {
    return (uint64_t)__top_b_inst_o_value_1;
}

extern "C" void VERILUA_DPI_EXPORTER_top_b_inst_o_value_1_GET_HEX_STR(char *hexStr) {
    uint32_t value = __top_b_inst_o_value_1;
    for(int i = 0; i >= 0; --i) {
        hexStr[i] = "0123456789abcdef"[value & 0xF];
        value >>= 4;
    }
    hexStr[1] = '\0';
}

extern "C" uint32_t VERILUA_DPI_EXPORTER_top_b_inst_o_value_2_GET() {
    return (uint32_t)__top_b_inst_o_value_2;
}

extern "C" uint64_t VERILUA_DPI_EXPORTER_top_b_inst_o_value_2_GET64() {
    return (uint64_t)__top_b_inst_o_value_2;
}

extern "C" void VERILUA_DPI_EXPORTER_top_b_inst_o_value_2_GET_HEX_STR(char *hexStr) {
    uint32_t value = __top_b_inst_o_value_2;
    for(int i = 0; i >= 0; --i) {
        hexStr[i] = "0123456789abcdef"[value & 0xF];
        value >>= 4;
    }
    hexStr[1] = '\0';
}

extern "C" uint32_t VERILUA_DPI_EXPORTER_top_b_inst_o_value_4_GET() {
    return (uint32_t)__top_b_inst_o_value_4;
}

extern "C" uint64_t VERILUA_DPI_EXPORTER_top_b_inst_o_value_4_GET64() {
    return (uint64_t)__top_b_inst_o_value_4;
}

extern "C" void VERILUA_DPI_EXPORTER_top_b_inst_o_value_4_GET_HEX_STR(char *hexStr) {
    uint32_t value = __top_b_inst_o_value_4;
    for(int i = 0; i >= 0; --i) {
        hexStr[i] = "0123456789abcdef"[value & 0xF];
        value >>= 4;
    }
    hexStr[1] = '\0';
}

extern "C" uint32_t VERILUA_DPI_EXPORTER_top_b_inst_o_value_5_GET() {
    return (uint32_t)__top_b_inst_o_value_5;
}

extern "C" uint64_t VERILUA_DPI_EXPORTER_top_b_inst_o_value_5_GET64() {
    return (uint64_t)__top_b_inst_o_value_5;
}

extern "C" void VERILUA_DPI_EXPORTER_top_b_inst_o_value_5_GET_HEX_STR(char *hexStr) {
    uint32_t value = __top_b_inst_o_value_5;
    for(int i = 0; i >= 0; --i) {
        hexStr[i] = "0123456789abcdef"[value & 0xF];
        value >>= 4;
    }
    hexStr[1] = '\0';
}

extern "C" uint32_t VERILUA_DPI_EXPORTER_top_b_inst_o_value_6_GET() {
    return (uint32_t)__top_b_inst_o_value_6;
}

extern "C" uint64_t VERILUA_DPI_EXPORTER_top_b_inst_o_value_6_GET64() {
    return (uint64_t)__top_b_inst_o_value_6;
}

extern "C" void VERILUA_DPI_EXPORTER_top_b_inst_o_value_6_GET_HEX_STR(char *hexStr) {
    uint32_t value = __top_b_inst_o_value_6;
    for(int i = 0; i >= 0; --i) {
        hexStr[i] = "0123456789abcdef"[value & 0xF];
        value >>= 4;
    }
    hexStr[1] = '\0';
}




extern "C" int64_t dpi_exporter_handle_by_name(std::string name) {
    static std::unordered_map<std::string, int64_t> name_to_handle = {
		{ "top_b_inst_valid1", 0 } /* hierPath: top.b_inst.valid1 bitWidth: 1 handleId: 0 */,
		{ "top_b_inst_o_value_0", 1 } /* hierPath: top.b_inst.o_value_0 bitWidth: 1 handleId: 1 */,
		{ "top_b_inst_o_value_1", 2 } /* hierPath: top.b_inst.o_value_1 bitWidth: 1 handleId: 2 */,
		{ "top_b_inst_o_value_2", 3 } /* hierPath: top.b_inst.o_value_2 bitWidth: 1 handleId: 3 */,
		{ "top_b_inst_o_value_4", 4 } /* hierPath: top.b_inst.o_value_4 bitWidth: 1 handleId: 4 */,
		{ "top_b_inst_o_value_5", 5 } /* hierPath: top.b_inst.o_value_5 bitWidth: 1 handleId: 5 */,
		{ "top_b_inst_o_value_6", 6 } /* hierPath: top.b_inst.o_value_6 bitWidth: 1 handleId: 6 */
    };

    auto it = name_to_handle.find(name);
    if (it != name_to_handle.end()) {
        return it->second;
    } else {
        return -1;
    }
}

extern "C" std::string dpi_exporter_get_type_str(int64_t handle) {
    static std::unordered_map<int64_t, std::string> handle_to_type_str = {
		{ 0, "vpiNet" } /* hierPath: top.b_inst.valid1 bitWidth: 1 handleId: 0 */,
		{ 1, "vpiNet" } /* hierPath: top.b_inst.o_value_0 bitWidth: 1 handleId: 1 */,
		{ 2, "vpiNet" } /* hierPath: top.b_inst.o_value_1 bitWidth: 1 handleId: 2 */,
		{ 3, "vpiNet" } /* hierPath: top.b_inst.o_value_2 bitWidth: 1 handleId: 3 */,
		{ 4, "vpiNet" } /* hierPath: top.b_inst.o_value_4 bitWidth: 1 handleId: 4 */,
		{ 5, "vpiNet" } /* hierPath: top.b_inst.o_value_5 bitWidth: 1 handleId: 5 */,
		{ 6, "vpiNet" } /* hierPath: top.b_inst.o_value_6 bitWidth: 1 handleId: 6 */
    };

    auto it = handle_to_type_str.find(handle);
    if (it != handle_to_type_str.end()) {
        return std::string(it->second);
    } else {
        return std::string("");
    }
}

extern "C" uint32_t dpi_exporter_get_bitwidth(int64_t handle) {
    static std::unordered_map<int64_t, uint32_t> handle_to_bitwidth = {
		{ 0, 1 } /* hierPath: top.b_inst.valid1 bitWidth: 1 handleId: 0 */,
		{ 1, 1 } /* hierPath: top.b_inst.o_value_0 bitWidth: 1 handleId: 1 */,
		{ 2, 1 } /* hierPath: top.b_inst.o_value_1 bitWidth: 1 handleId: 2 */,
		{ 3, 1 } /* hierPath: top.b_inst.o_value_2 bitWidth: 1 handleId: 3 */,
		{ 4, 1 } /* hierPath: top.b_inst.o_value_4 bitWidth: 1 handleId: 4 */,
		{ 5, 1 } /* hierPath: top.b_inst.o_value_5 bitWidth: 1 handleId: 5 */,
		{ 6, 1 } /* hierPath: top.b_inst.o_value_6 bitWidth: 1 handleId: 6 */
    };

    auto it = handle_to_bitwidth.find(handle);
    if (it != handle_to_bitwidth.end()) {
        return it->second;
    } else {
        return 0;
    }
}

extern "C" GetValue32Func dpi_exporter_alloc_get_value32(int64_t handle) {
    static std::unordered_map<int64_t, GetValue32Func> handle_to_func = {
		{ 0, VERILUA_DPI_EXPORTER_top_b_inst_valid1_GET } /* hierPath: top.b_inst.valid1 bitWidth: 1 handleId: 0 */,
		{ 1, VERILUA_DPI_EXPORTER_top_b_inst_o_value_0_GET } /* hierPath: top.b_inst.o_value_0 bitWidth: 1 handleId: 1 */,
		{ 2, VERILUA_DPI_EXPORTER_top_b_inst_o_value_1_GET } /* hierPath: top.b_inst.o_value_1 bitWidth: 1 handleId: 2 */,
		{ 3, VERILUA_DPI_EXPORTER_top_b_inst_o_value_2_GET } /* hierPath: top.b_inst.o_value_2 bitWidth: 1 handleId: 3 */,
		{ 4, VERILUA_DPI_EXPORTER_top_b_inst_o_value_4_GET } /* hierPath: top.b_inst.o_value_4 bitWidth: 1 handleId: 4 */,
		{ 5, VERILUA_DPI_EXPORTER_top_b_inst_o_value_5_GET } /* hierPath: top.b_inst.o_value_5 bitWidth: 1 handleId: 5 */,
		{ 6, VERILUA_DPI_EXPORTER_top_b_inst_o_value_6_GET } /* hierPath: top.b_inst.o_value_6 bitWidth: 1 handleId: 6 */
    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" GetValueVecFunc dpi_exporter_alloc_get_value_vec(int64_t handle) {
    static std::unordered_map<int64_t, GetValueVecFunc> handle_to_func = {

    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" GetValueHexStrFunc dpi_exporter_alloc_get_value_hex_str(int64_t handle) {
    static std::unordered_map<int64_t, GetValueHexStrFunc> handle_to_func = {
		{ 0, VERILUA_DPI_EXPORTER_top_b_inst_valid1_GET_HEX_STR } /* hierPath: top.b_inst.valid1 bitWidth: 1 handleId: 0 */,
		{ 1, VERILUA_DPI_EXPORTER_top_b_inst_o_value_0_GET_HEX_STR } /* hierPath: top.b_inst.o_value_0 bitWidth: 1 handleId: 1 */,
		{ 2, VERILUA_DPI_EXPORTER_top_b_inst_o_value_1_GET_HEX_STR } /* hierPath: top.b_inst.o_value_1 bitWidth: 1 handleId: 2 */,
		{ 3, VERILUA_DPI_EXPORTER_top_b_inst_o_value_2_GET_HEX_STR } /* hierPath: top.b_inst.o_value_2 bitWidth: 1 handleId: 3 */,
		{ 4, VERILUA_DPI_EXPORTER_top_b_inst_o_value_4_GET_HEX_STR } /* hierPath: top.b_inst.o_value_4 bitWidth: 1 handleId: 4 */,
		{ 5, VERILUA_DPI_EXPORTER_top_b_inst_o_value_5_GET_HEX_STR } /* hierPath: top.b_inst.o_value_5 bitWidth: 1 handleId: 5 */,
		{ 6, VERILUA_DPI_EXPORTER_top_b_inst_o_value_6_GET_HEX_STR } /* hierPath: top.b_inst.o_value_6 bitWidth: 1 handleId: 6 */
    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" SetValue32Func dpi_exporter_alloc_set_value32(int64_t handle) {
    static std::unordered_map<int64_t, SetValue32Func> handle_to_func = {

    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" SetValueVecFunc dpi_exporter_alloc_set_value_vec(int64_t handle) {
    static std::unordered_map<int64_t, SetValueVecFunc> handle_to_func = {

    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" SetValueHexStrFunc dpi_exporter_alloc_set_value_hex_str(int64_t handle) {
    static std::unordered_map<int64_t, SetValueHexStrFunc> handle_to_func = {

    };

    auto it = handle_to_func.find(handle);
    if (it!= handle_to_func.end()) {
        return it->second;
    } else {
        return nullptr;
    }
}

extern "C" char *dpi_exporter_get_top_name() {
    static char top_name[] = "top";
    return top_name;
}

extern "C" char *dpi_exporter_get_meta_info_file_path() {
    static char meta_info_file_path[] = ".dpi_exporter_only_sensitive/dpi_exporter.meta.json";
    return meta_info_file_path;
}



// Call verilua_main_step_safe() in dpi_exporter_tick() if `DPI_EXP_CALL_VERILUA_ENV_STEP` macro is defined.
// Only available when `distributeDPI` is 0.
#ifdef DPI_EXP_CALL_VERILUA_ENV_STEP

// The `DPI_EXP_USE_STRICT_STEP` macro controls error handling semantics for the Verilua step
// invoked from the simulator:
// - If `DPI_EXP_USE_STRICT_STEP` is defined, `verilua_main_step()` is used. In strict mode,
//   any uncaught Lua error will cause an immediate termination of the whole simulation. Use this
//   when you prefer fail-fast semantics and want simulation to stop on script errors.
// - If `DPI_EXP_USE_STRICT_STEP` is NOT defined, `verilua_main_step_safe()` is used. In safe
//   mode, Lua errors are caught/reported and the simulator continues running. Use this when you
//   need resilience to scripting errors and prefer the simulator to keep running.
#ifdef DPI_EXP_USE_STRICT_STEP
extern "C" void verilua_main_step();
#else // DPI_EXP_USE_STRICT_STEP
extern "C" void verilua_main_step_safe();
#endif // DPI_EXP_USE_STRICT_STEP


bool hasSignalChanged = false; // Used for sensitive signals to indicate if there is a change in all sensitive signals.


#endif // DPI_EXP_CALL_VERILUA_ENV_STEP

extern "C" void dpi_exporter_tick() {


#ifdef DPI_EXP_CALL_VERILUA_ENV_STEP

#ifdef DPI_EXP_USE_STRICT_STEP
    verilua_main_step();
#else // DPI_EXP_USE_STRICT_STEP
    verilua_main_step_safe();
#endif // DPI_EXP_USE_STRICT_STEP


    hasSignalChanged = false;
    

#endif // DPI_EXP_CALL_VERILUA_ENV_STEP
}


extern "C" void dpi_exporter_tick_o_signals(const uint8_t top_b_inst_valid1, const uint8_t top_b_inst_o_value_0, const uint8_t top_b_inst_o_value_1, const uint8_t top_b_inst_o_value_2, const uint8_t top_b_inst_o_value_4, const uint8_t top_b_inst_o_value_5, const uint8_t top_b_inst_o_value_6) {
	__top_b_inst_valid1 = top_b_inst_valid1;
	__top_b_inst_o_value_0 = top_b_inst_o_value_0;
	__top_b_inst_o_value_1 = top_b_inst_o_value_1;
	__top_b_inst_o_value_2 = top_b_inst_o_value_2;
	__top_b_inst_o_value_4 = top_b_inst_o_value_4;
	__top_b_inst_o_value_5 = top_b_inst_o_value_5;
	__top_b_inst_o_value_6 = top_b_inst_o_value_6;

#ifdef DPI_EXP_CALL_VERILUA_ENV_STEP
    hasSignalChanged = true;
    
#endif
}



// When sensitive signal groups are updated(i.e. dpi_exporter_tick_<SensitiveGroupName>), this function can be used to check whether any signal has changed.
// Normally used for optimizing the performance of obtaining signal values by reducing unnecessary signal value sampling actions.
extern "C" bool dpi_exporter_sensitive_trigger() {
#ifdef DPI_EXP_CALL_VERILUA_ENV_STEP

    return hasSignalChanged;

#else
    assert(0 && "dpi_exporter_sensitive_trigger() should not be called when cflags macro DPI_EXP_CALL_VERILUA_ENV_STEP is not defined");
#endif
}


 
