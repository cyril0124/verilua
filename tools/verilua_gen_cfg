#!/usr/bin/env python3

from os import path
from enum import Enum, auto
from typing import List
import lupa
import os
import argparse
from lupa import LuaRuntime

class VeriluaMode(Enum):
    NORMAL = auto()
    STEP = auto()
    DOMINANT = auto()

class VeriluaCfg:
    def __init__(self) -> None:
        self.top: str = None
        self.simulator: str = None
        self.mode: VeriluaMode = None
        self.clock: str = None
        self.reset: str = None
        self.seed: int = None
        self.attach: bool = None
        self.script: str = None
        self.prj_dir: str = None
        self.srcs: List[str] = []
        self.deps: List[str] = []
        self.configs: List[(str, str)] = []
        self.period: int = None
        self.unit: str = None
        self.enable_shutdown: bool = None
        self.shutdown_cycles: int = None
        self.luapanda_debug: bool = None
        self.vpi_learn: bool = None

def vl_print(*args, **kwargs):
    print("[VERILUA]", *args, **kwargs)


parser = argparse.ArgumentParser(description='')
parser.add_argument('--target', '-t', dest="target", type=str, default="main", help='')

args = parser.parse_args()
assert args.target != None

# if "VERILUA_CFG" not in os.environ:
#     assert False, "VERILUA_CFG is not set!"

cfg = VeriluaCfg()
lua = LuaRuntime(unpack_returned_tuples=True)

lua.execute('''
    _G.cfg = {}
    require "verilua_cfg"
    
    function print_table(tbl, key, level)
        level  = level or 0
        for k, v in pairs(tbl) do
            if type(v) == "table" then
                prefix = string.rep("\\t", level)
                print(prefix .. k .. ":")
                print_table(v, k, level + 1)
            else
                if key == nil then
                    print(k, "=", v)
                else
                    prefix = string.rep("\\t", level)
                    print(prefix .. k, "=", v)
                end
            end
        end
    end
    
    print_table(basic, nil, 0)
    
    if deps ~= nil then
        print_table(deps, nil, 0)
    end
    
    if configs ~= nil then
        print_table(configs, nil, 0)
    end
''')


verilua_cfg = lua.globals()

basic_cfg = verilua_cfg["basic"]
basic_cfg_keys = [
    "top",    
    "simulator",     
    "mode", 
    "script", 
    "srcs",     
    "seed", 
    "attach", 
    "prj_dir", 
    "period",
    "unit", 
    "shutdown_cycles", 
    "enable_shutdown",
    "luapanda_debug",
    "vpi_learn"
]

for item in basic_cfg_keys:
    cfg_item = basic_cfg[item]
    
    if item == "top":
        assert cfg_item != None, "<top> should be set properly!"
        assert type(cfg_item) == str
        cfg.top = cfg_item
    elif item == "simulator":
        assert cfg_item != None, "<simulator> should be set properly!"
        assert cfg_item in ["verilator", "vcs", "iverilog", "wave_vpi"], f"Simulator only support verilator or vcs, not {cfg_item}"
        assert type(cfg_item) == str
        cfg.simulator = cfg_item  
    elif item == "mode":
        if cfg_item in ["STEP", "step", "S", "s"]:
            cfg.mode = VeriluaMode.STEP
        elif cfg_item in ["NORMAL", "normal", "N", "n"]:
            cfg.mode = VeriluaMode.NORMAL
        elif cfg_item in ["DOMINANT", "dominant", "D", "d"]:
            cfg.mode = VeriluaMode.DOMINANT
        else:
            assert False, f"Unknown mode => {cfg_item}"
    elif item == "script":
        assert cfg_item != None, "<script> should be set properly!"
        assert type(cfg_item) == str
        cfg.script = path.abspath(cfg_item)
    elif item == "srcs":
        assert cfg_item != None, "<srcs> should be set properly!"
        if type(cfg_item) == str:
            cfg.srcs.append(path.abspath(cfg_item))
        else:
            for i, src in cfg_item.items():
                assert type(src) == str
                cfg.srcs.append(path.abspath(src))
    elif item == "seed":
        if cfg_item != None:
            assert type(cfg_item) == int
            cfg.seed = cfg_item
    elif item == "attach":
        if cfg_item != None:
            assert type(cfg_item) == bool
            cfg.attach = cfg_item
    elif item == "prj_dir":
        if cfg_item != None:
            assert type(cfg_item) == str
            cfg.prj_dir = cfg_item
    elif item == "period":
        if cfg_item != None:
            assert type(cfg_item) == int
            cfg.period = cfg_item
    elif item == "unit":
        if cfg_item != None:
            assert type(cfg_item) == str
            cfg.unit = cfg_item
    elif item == "shutdown_cycles":
        if cfg_item != None:
            assert type(cfg_item) == int
            cfg.shutdown_cycles = cfg_item
    elif item == "enable_shutdown":
        if cfg_item != None:
            assert type(cfg_item) == bool
            cfg.enable_shutdown = cfg_item
    elif item == "luapanda_debug":
        if cfg_item != None:
            assert type(cfg_item) == bool
            cfg.luapanda_debug = cfg_item
    elif item == "vpi_learn":
        if cfg_item != None:
            assert type(cfg_item) == bool
            cfg.vpi_learn = cfg_item
    else:
        assert False, f"Unknown item => {item}"


if cfg.mode == None:
    cfg.mode = VeriluaMode.NORMAL
    vl_print(f"<mode> is not set, using default => {cfg.mode}")

if cfg.clock == None:
    cfg.clock = f"{cfg.top}.clock"
    vl_print(f"<basic.clock> is not set, using default => {cfg.clock}")

if cfg.reset == None:
    cfg.reset = f"{cfg.top}.reset"
    vl_print(f"<basic.reset> is not set, using default => {cfg.reset}")

if cfg.seed == None:
    cfg.seed = 0
    vl_print(f"<basic.seed> is not set, using default => {cfg.seed}")

if cfg.attach == None:
    cfg.attach = False
    vl_print(f"<basic.attach> is not set, using default => {cfg.attach}")

if cfg.prj_dir == None:
    cfg.prj_dir = os.getcwd()
    vl_print(f"<basic.prj_dir> is not set, using default => {cfg.prj_dir}")

if cfg.period == None:
    cfg.period = 10
    vl_print(f"<basic.period> is not set, using default => {cfg.period}")

if cfg.unit == None:
    cfg.unit = "ns"
    vl_print(f"<basic.unit> is not set, using default => {cfg.unit}")
    
if cfg.shutdown_cycles == None:
    cfg.shutdown_cycles = 10000
    vl_print(f"<basic.shutdown_cycles> is not set, using default => {cfg.shutdown_cycles}")

if cfg.enable_shutdown == None:
    cfg.enable_shutdown = True
    vl_print(f"<basic.enable_shutdown> is not set, using default => {cfg.enable_shutdown}")

if cfg.luapanda_debug == None:
    cfg.luapanda_debug = False
    vl_print(f"<basic.luapanda_debug> is not set, using default => {cfg.luapanda_debug}")

if cfg.vpi_learn == None:
    cfg.vpi_learn = False
    vl_print(f"<basic.vpi_learn> is not set, using default => {cfg.vpi_learn}")


deps = verilua_cfg["deps"]
if deps != None:
    for name, _path in deps.items():
        assert type(name) == str
        assert type(_path) == str
        cfg.deps.append((name, path.abspath(_path)))


def remove_dot_lua(s):
    if s.endswith(".lua"):
        return s.replace(".lua", "", 1)
    return s

configs = verilua_cfg["configs"]
if configs != None:
    for name, config in configs.items():
        assert type(name) == str
        assert type(config) == str
        cfg.configs.append((name, path.abspath(remove_dot_lua(config))))
    
def gen_cfg_file(target):
    f = open(f'verilua_cfg_{target}.lua', 'w')
    # f = open(f'verilua_cfg.{args.target}.lua', 'w')
    print('local LuaSimConfig = require "LuaSimConfig"', file=f)
    print('local cfg = require "LuaBasicConfig"\n', file=f)
    print('local VeriluaMode = LuaSimConfig.VeriluaMode\n', file=f)

    # print(f'cfg.name = "{args.target}"', file=f)
    # print(f'cfg.target = "{args.target}"', file=f)
    print(f'cfg.name = "{target}"', file=f)
    print(f'cfg.target = "{target}"', file=f)
    for attr_name, attr_value in cfg.__dict__.items():
        if isinstance(attr_value, list):
            if attr_name == "deps" and (attr_value == None or len(attr_value) == 0):
                continue
            if attr_name == "configs" and (attr_value == None or len(attr_value) == 0):
                continue
            
            if isinstance(attr_value[0], tuple):
                assert attr_name in ["configs", "deps"], attr_name
                if attr_name == "configs":
                    print(f"cfg.{attr_name} = {{", file=f)
                    for item in attr_value:
                        name = item[0]
                        value = path.abspath(item[1])
                        value = path.basename(value)
                        assert isinstance(value, str)
                        print(f'\t{name} = "{value}",', file=f)
                    print("}", file=f)
                    
                    print(f"cfg.{attr_name}_path = {{", file=f)
                    for item in attr_value:
                        name = item[0]
                        value = path.dirname(item[1])
                        assert isinstance(value, str)
                        print(f'\t{name} = "{value}",', file=f)
                    print("}", file=f)
                else:
                    print(f"cfg.{attr_name} = {{", file=f)
                    for item in attr_value:
                        name = item[0]
                        value = path.abspath(item[1])
                        assert isinstance(value, str)
                        print(f'\t{name} = "{value}",', file=f)
                    print("}", file=f)
            else:
                if len(attr_value) >= 1:
                    assert isinstance(attr_value[0], str), type(attr_value[0])
                    tmp = "{\"" + "\", \"".join(map(str, attr_value)) + "\"}"
                    print(f'cfg.{attr_name} = {tmp}', file=f)
                else:
                    print(f'cfg.{attr_name} = {{}}', file=f)
        else:
            v = attr_value
            if isinstance(attr_value, bool):
                v = str(attr_value).lower()
            elif isinstance(attr_value, str):
                v = '\"' + attr_value + '\"'
            if attr_name == "simulator":
                print(f'cfg.{attr_name} = os.getenv("SIM") or {v}', file=f)
            elif attr_name == "shutdown_cycles":
                print(f'cfg.{attr_name} = os.getenv("SHUTDOWN_CYCLES") or {v}', file=f)
            elif attr_name == "top":
                print(f'cfg.{attr_name} = os.getenv("DUT_TOP") or {v}', file=f)
            elif attr_name == "script":
                print(f'cfg.{attr_name} = os.getenv("LUA_SCRIPT") or {v}', file=f)
            elif attr_name == "prj_dir":
                print(f'cfg.{attr_name} = os.getenv("PRJ_TOP") or {v}', file=f)
            elif attr_name == "seed":
                print(f'cfg.{attr_name} = os.getenv("SEED") or {v}', file=f)
            else:
                print(f'cfg.{attr_name} = {v}', file=f)

    print("""

--
-- Mix with other config
--
local function configs_len(cfg)
    local len = 0
    if cfg.configs ~= nil then
        for key, value in pairs(cfg.configs) do
            len = len + 1
        end
        return len
    else
        return 0
    end
end

if configs_len(cfg) ~= 0 then
    local found = false
    for k, v in pairs(cfg.configs) do
        if k == cfg.target then
            assert(not found, "Duplicate target => " .. cfg.target)
            assert(cfg.configs_path[k] ~= nil)
            package.path = package.path .. ";" .. cfg.configs_path[k] .. "/?.lua"
            
            local _cfg = require(v)
            LuaSimConfig.CONNECT_CONFIG(_cfg, cfg)
            found = true
        end
    end
    assert(found == true, "Not found any configs match target => " .. cfg.target) 
end
    """, file=f)

    print('\nreturn cfg', file=f)
    f.close()


if len(cfg.configs) != 0:
    for (target, _) in cfg.configs:
        gen_cfg_file(target)
else:
    gen_cfg_file("unknown")
