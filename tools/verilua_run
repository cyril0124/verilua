#!/usr/bin/env python3

import os
import sys
import subprocess
import argparse
import filecmp

def execute_cmd(cmd):
    return subprocess.run(cmd, shell=True, capture_output=True, text=True)

def execute_cmd_pipe(cmd):
    process = subprocess.Popen(cmd, shell=True, text=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    while True:
        output = process.stdout.readline()
        if output == '' and process.poll() is not None:
            break
        if output:
            print(output.strip())
    
    rc = process.poll()
    return rc

parser = argparse.ArgumentParser(description='A script used for running a simple dut.')
parser.add_argument('--file', '-f', action='append', dest="file", required=True, help='input verilog file')
parser.add_argument('--top_file', '-tf', dest="top_file", type=str, required=True, help='input top-level verilog file')
parser.add_argument('--top', '-t', dest="top", type=str, required=True, help='top module name')
parser.add_argument('--sim', choices=['vcs', 'verilator'], dest="sim", required=True, help="simulator of the simulation")
parser.add_argument('--lua_main', '-l', dest="lua_main", type=str, required=True, help='input lua main script file')
parser.add_argument('--lua_file', '-lf', action='append', dest="lua_file", default=[], help='input Lua file')
parser.add_argument('--shutdown', '-s', dest="shutdown", type=str, default="10000", help='shutdown cycles')
parser.add_argument('--rebuild', '-r', dest="rebuild", action="store_true", default=False, help='force rebuild')
parser.add_argument('--no-generate-tb', '-ngt', dest="no_generate_tb", action="store_true", default=False, help='do not generate testbench')
parser.add_argument('--prjdir', '-p', dest="prjdir", type=str, required=True, help='project directory')
parser.add_argument('--workdir-name', '-wn', dest="workdir_name", type=str, default=".verilua", help='working directory name')

args = parser.parse_args()

files       = [os.path.abspath(f) for f in args.file]
lua_files   = [os.path.abspath(f) for f in args.lua_file]
top_file    = os.path.abspath(args.top_file)

lua_main      = os.path.abspath(args.lua_main)
lua_files.append(lua_main)
lua_main_name = os.path.basename(lua_main)
prj_dir       = os.path.abspath(args.prjdir)
workdir_name  = args.workdir_name
work_dir      = f"{prj_dir}/{workdir_name}"
test_dir      = f"{work_dir}/{args.top}"
dut_dir       = f"{test_dir}/dut"
rtl_dir       = f"{dut_dir}/rtl"
cache_dir     = f"{test_dir}/cache"

need_rebuild = False

print("[verilua_run] prjdir => ", prj_dir)
print("[verilua_run] workdir => ", work_dir)

execute_cmd(f'mkdir -p {work_dir}')
execute_cmd(f'mkdir -p {test_dir}')
execute_cmd(f'mkdir -p {dut_dir}')
execute_cmd(f'mkdir -p {rtl_dir}')
execute_cmd(f'mkdir -p {cache_dir}')

check_files = files + lua_files
check_files.append(top_file)
for file in check_files:
    if not os.path.isfile(file):
        assert False, f"file: {lua_main} does not exist!"

for file in files + lua_files:
    file_name = os.path.basename(file)
    if not os.path.exists(f"{cache_dir}/{file_name}"):
        need_rebuild = True
        execute_cmd(f"cp {file} {cache_dir}/{file_name}")

for file in lua_files:
    file_name = os.path.basename(file)
    if not os.path.exists(f"{test_dir}/{file_name}"):
        execute_cmd(f"cp {file} {test_dir}/")

verilua_home = os.environ["VERILUA_HOME"]
execute_cmd(f"cp {verilua_home}/scripts/makefiles/* {test_dir}")

# find mismatch rtl file
has_mismatch_rtl = False
for file in files:
    file_name = os.path.basename(file)
    if os.path.isfile(f"{cache_dir}/{file_name}"):
        if not filecmp.cmp(file, f"{cache_dir}/{file_name}", shallow=False):
            has_mismatch_rtl = True

# update mismatch file
if has_mismatch_rtl:
    for file in files:
        file_name = os.path.basename(file)
        execute_cmd(f"cp {file} {cache_dir}/{file_name}")

# find mismatch lua file
has_mismatch_lua = False
for file in lua_files:
    name = os.path.basename(file)
    if not filecmp.cmp(file, f"{cache_dir}/{name}", shallow=False):
        has_mismatch_lua = True

# update mismatch file
if has_mismatch_lua:
    for file in lua_files:
        execute_cmd(f"cp {file} {test_dir}/")
    

if has_mismatch_rtl:
    need_rebuild = True

if need_rebuild:
    for file in files:
        execute_cmd(f"cp {file} {rtl_dir}")

verilua_cfg_gen_file = f"{test_dir}/verilua_cfg_unknown.lua"
verilua_cfg_lua = f"""
basic = {{
    test_dir = os.getenv("$PWD"),
    top = "tb_top",
    simulator = "{args.sim}",
    mode = "normal",
    script = "{test_dir}/{os.path.basename(args.lua_main)}",
    period = 10,
    unit = "ns",
    seed = 0,
    attach = false,
    enable_shutdown = true,
    shutdown_cycles = {args.shutdown},
    srcs = {{
        "./?.lua",
    }},
}}
"""

os.environ['SIM']         = args.sim
os.environ['VERILUA_CFG'] = verilua_cfg_gen_file

verilua_cfg_lua_file = f'{test_dir}/verilua_cfg.lua'
with open(verilua_cfg_lua_file, 'w', encoding='utf-8') as file:
    file.write(verilua_cfg_lua)

ret = execute_cmd(f"cd {test_dir}; verilua_gen_cfg")
if ret.stderr:
    assert False, f"==> {ret.stderr}"

if not os.path.exists(f"{test_dir}/sim_build"):
    need_rebuild = True

print("[verilua_run] args =>", args)
print("[verilua_run] has_mismatch_rtl =>", has_mismatch_rtl)
print("[verilua_run] has_mismatch_lua =>", has_mismatch_lua)
print("[verilua_run] need_rebuild =>", need_rebuild)

if args.sim == "vcs":
    if not os.path.isfile(f"{test_dir}/sim_build/simv"):
        need_rebuild = True
elif args.sim == "verilator":
    if not os.path.isfile(f"{test_dir}/sim_build/Vtb_top"):
        need_rebuild = True

# create a clean.sh + build.sh + run.sh that can be used by user to manually run the simulation without using verilua_run
clean_sh=f"""
#!/bin/bash
export VERILUA_CFG={verilua_cfg_gen_file}
export SIM={args.sim}
make clean
"""
build_sh=f"""
#!/bin/bash
export VERILUA_CFG={verilua_cfg_gen_file}
export SIM={args.sim}
make build | tee build.log
"""
run_sh=f"""
#!/bin/bash
export VERILUA_CFG={verilua_cfg_gen_file}
export SIM={args.sim}
make run | tee run.log
"""

scripts = [(clean_sh, "clean.sh"), (build_sh, "build.sh"), (run_sh, "run.sh")]
for (script, name) in scripts:
    with open(f"{test_dir}/{name}", 'w', encoding='utf-8') as file:
        file.write(script)
    execute_cmd(f"chmod 777 {test_dir}/{name}")

if need_rebuild or args.rebuild:
    if not args.no_generate_tb:
        ret = execute_cmd(f"/usr/bin/env python3 $VERILUA_HOME/scripts/testbench_gen.py -f {top_file} --top {args.top} --nodpi --dir {dut_dir}")
        if ret.stderr:
            assert False, f"==> {ret.stderr}"
    
    print("[verilua_run] start build...")
    ret = execute_cmd_pipe(f"cd {test_dir}; make clean; make build | tee build.log")
    if isinstance(ret, int) and ret != 0:
        assert False, "build failed!"
    if not isinstance(ret, int) and ret.stderr != None:
        assert False, f"build failed! ==> {ret.stderr}"
    if execute_cmd(f'grep "BUILD SUCCESS" {test_dir}/build.log -q; echo $?').stdout.strip("\n") == "1":
        assert False, "build failed!"    

    print("[verilua_run] start run...")
    execute_cmd_pipe(f"cd {test_dir}; export VERILUA_CFG={verilua_cfg_gen_file}; export SIM={args.sim}; make run | tee run.log")
else:
    print("[verilua_run] start run...")
    execute_cmd_pipe(f"cd {test_dir}; export VERILUA_CFG={verilua_cfg_gen_file}; export SIM={args.sim}; make run | tee run.log")

