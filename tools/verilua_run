#!/usr/bin/env python3

import os
import sys
import subprocess
import argparse
import filecmp

def execute_cmd(cmd):
    return subprocess.run(cmd, shell=True, capture_output=True, text=True)

def execute_cmd_pipe(cmd):
    process = subprocess.Popen(cmd, shell=True, text=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    while True:
        output = process.stdout.readline()
        if output == '' and process.poll() is not None:
            break
        if output:
            print(output.strip())
    
    rc = process.poll()
    return rc

parser = argparse.ArgumentParser(description='A script used for running a simple dut.')
parser.add_argument('--file', '-f', action='append', dest="file", required=True, help='input verilog file')
parser.add_argument('--top_file', '-tf', dest="top_file", type=str, required=True, help='input top-level verilog file')
parser.add_argument('--top', '-t', dest="top", type=str, required=True, help='top module name')
parser.add_argument('--sim', choices=['vcs', 'verilator'], dest="sim", required=True, help="simulator of the simulation")
parser.add_argument('--lua_main', '-l', dest="lua_main", type=str, required=True, help='input lua main script file')
parser.add_argument('--shutdown', '-s', dest="shutdown", type=str, default="10000", help='shutdown cycles')
parser.add_argument('--rebuild', '-r', dest="rebuild", action="store_true", default=False, help='force rebuild')
parser.add_argument('--workdir', '-w', dest="workdir", type=str, help='working directory')

args = parser.parse_args()

workdir = os.path.abspath(args.workdir)
files = [os.path.abspath(f) for f in args.file]

lua_main = os.path.abspath(args.lua_main)
lua_main_name = os.path.basename(lua_main)
dut_dir = f"{workdir}/.verilua/{args.top}/dut"
rtl_dir = f"{dut_dir}/rtl"
cache_dir = f"{workdir}/.verilua/{args.top}/cache"
prj_dir = f"{workdir}/.verilua/{args.top}"

execute_cmd(f'mkdir -p {workdir}/.verilua')
execute_cmd(f'mkdir -p {workdir}/.verilua/{args.top}')
execute_cmd(f'mkdir -p {dut_dir}')
execute_cmd(f'mkdir -p {rtl_dir}')
execute_cmd(f'mkdir -p {cache_dir}')

print("[verilua_run] workdir => ", workdir)

need_rebuild = False

for file in files:
    file_name = os.path.basename(file)
    if not os.path.isfile(f"{rtl_dir}/{file_name}"):
        need_rebuild = True
        execute_cmd(f"cp {file} {rtl_dir}/{file_name}")

if not os.path.isfile(f"{cache_dir}/{lua_main_name}"):
    execute_cmd(f"cp {lua_main} {cache_dir}/{lua_main_name}")

verilua_home = os.environ["VERILUA_HOME"]
execute_cmd(f"cp {verilua_home}/scripts/makefiles/* {prj_dir}")

# find mismatch rtl file
has_mismatch_rtl = False
for file in files:
    file_name = os.path.basename(file)
    # print(file_name, cache_dir, file)
    if os.path.isfile(f"{cache_dir}/{file_name}"):
        if not filecmp.cmp(file, f"{cache_dir}/{file_name}", shallow=False):
            has_mismatch_rtl = True

# update mismatch file
if has_mismatch_rtl:
    for file in files:
        file_name = os.path.basename(file)
        execute_cmd(f"cp {file} {cache_dir}/{file_name}")

# find mismatch lua main file
has_mismatch_lua_main = False
if not filecmp.cmp(lua_main, f"{cache_dir}/{lua_main_name}", shallow=False):
    has_mismatch_lua_main = True

# update mismatch file
if has_mismatch_lua_main:
    execute_cmd(f"cp {lua_main} {cache_dir}/{lua_main_name}")


if has_mismatch_rtl:
    need_rebuild = True

if need_rebuild:
    for file in files:
        execute_cmd(f'cp {file} {workdir}/.verilua/{args.top}/dut/rtl')

verilua_cfg_gen_file = f"{workdir}/.verilua/{args.top}/verilua_cfg_unknown.lua"
verilua_cfg_lua = f"""
basic = {{
    prj_dir = os.getenv("$PWD"),
    top = "{args.top}",
    simulator = "{args.sim}",
    mode = "normal",
    script = "{os.path.abspath(args.lua_main)}",
    period = 10,
    unit = "ns",
    seed = 0,
    attach = false,
    enable_shutdown = true,
    shutdown_cycles = {args.shutdown},
    srcs = {{
        "./?.lua",
    }},
}}
"""

os.environ['SIM'] = args.sim
os.environ['VERILUA_CFG'] = verilua_cfg_gen_file

verilua_cfg_lua_file = f'{workdir}/.verilua/{args.top}/verilua_cfg.lua'
with open(verilua_cfg_lua_file, 'w', encoding='utf-8') as file:
    file.write(verilua_cfg_lua)

ret = execute_cmd(f"cd {workdir}/.verilua/{args.top}; verilua_gen_cfg")
if ret.stderr:
    assert False, f"==> {ret.stderr}"

if not os.path.exists(f"{prj_dir}/sim_build"):
    need_rebuild = True

print("[verilua_run] args =>", args)
print("[verilua_run] has_mismatch_rtl =>", has_mismatch_rtl)
print("[verilua_run] has_mismatch_lua_main =>", has_mismatch_lua_main)
print("[verilua_run] need_rebuild =>", need_rebuild)


if need_rebuild or args.rebuild:
    ret = execute_cmd(f"/usr/bin/env python3 $VERILUA_HOME/scripts/testbench_gen.py -f {args.top_file} --top {args.top} --nodpi --dir {dut_dir}")
    if ret.stderr:
        assert False, f"==> {ret.stderr}"
    ret = execute_cmd_pipe(f"cd {prj_dir}; make clean; make build; VERILUA_CFG={verilua_cfg_gen_file} make run")
    if ret.stderr:
        assert False, f"==> {ret.stderr}"
else:
    execute_cmd_pipe(f"cd {prj_dir}; VERILUA_CFG={verilua_cfg_gen_file} make run")

