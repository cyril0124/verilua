#!/usr/bin/env python3

import os
import subprocess
import argparse
import filecmp

def execute_cmd(cmd):
    return subprocess.run(cmd, shell=True, capture_output=True, text=True)

def execute_cmd_pipe(cmd):
    return subprocess.run(cmd, shell=True, stderr=subprocess.PIPE, text=True)

def extract_filelist(file):
    if file.endswith(".f"):
        assert file.endswith(".f")
        filelist = []
        with open(os.path.abspath(file), "r") as f:
            for line in f:
                if line.strip():
                    ff = line.strip()
                    assert os.path.exists(ff)
                    ff = os.path.abspath(ff)
                    filelist.append(ff)
        s = "\n".join(filelist)
        print(f"get filelist => \n{s}")
        return filelist
    else:
        return os.path.abspath(file)

parser = argparse.ArgumentParser(description='A script used for running a simple dut.')
parser.add_argument('--file', '-f', action='append', dest="file", required=True, help='input verilog file')
parser.add_argument('--top_file', '-tf', dest="top_file", type=str, required=True, help='input top-level verilog file')
parser.add_argument('--top', '-t', dest="top", type=str, required=True, help='top module name')
parser.add_argument('--sim', choices=['vcs', 'verilator'], dest="sim", required=True, help="simulator of the simulation")
parser.add_argument('--lua_main', '-l', dest="lua_main", type=str, required=True, help='input lua main script file')
parser.add_argument('--lua_file', '-lf', action='append', dest="lua_file", default=[], help='input Lua file')
parser.add_argument('--shutdown', '-s', dest="shutdown", type=str, default="10000", help='shutdown cycles')
parser.add_argument('--rebuild', '-r', dest="rebuild", action="store_true", default=False, help='force rebuild')
parser.add_argument('--no-generate-tb', '-ngt', dest="no_generate_tb", action="store_true", default=False, help='do not generate testbench')
parser.add_argument('--prjdir', '-p', dest="prjdir", type=str, required=True, help='project directory')
parser.add_argument('--workdir-name', '-wn', dest="workdir_name", type=str, default=".verilua", help='working directory name')
parser.add_argument('--tb-gen-args', '-tga', dest="tb_gen_args", type=str, default="", help='arguments pass into <testbench_gen.py>')
parser.add_argument('--makefile-args', '-ma', dest="makefile_args", type=str, default="", help='arguments pass into Makfile')


args = parser.parse_args()

# parse filelist
_files = []
for f in args.file:
    filelist_or_file = extract_filelist(f)
    if isinstance(filelist_or_file, list):
        for ff in filelist_or_file:
            _files.append(ff)
    else:
        assert isinstance(filelist_or_file, str), f"{type(filelist_or_file)}"
        _files.append(filelist_or_file)

# parse filelist
_lua_files = []
for f in args.lua_file:
    filelist_or_file = extract_filelist(f)
    if isinstance(filelist_or_file, list):
        for ff in filelist_or_file:
            _lua_files.append(ff)
    else:
        assert isinstance(filelist_or_file, str), f"{type(filelist_or_file)}"
        _lua_files.append(filelist_or_file)

files       = [os.path.abspath(f) for f in _files]
lua_files   = [os.path.abspath(f) for f in _lua_files]
top_file    = os.path.abspath(args.top_file)

lua_main      = os.path.abspath(args.lua_main)
lua_files.append(lua_main)
lua_main_name = os.path.basename(lua_main)
prj_dir       = os.path.abspath(args.prjdir)
workdir_name  = args.workdir_name
work_dir      = f"{prj_dir}/{workdir_name}"
test_dir      = f"{work_dir}/{args.top}"
dut_dir       = f"{test_dir}/dut"
rtl_dir       = f"{dut_dir}/rtl"
cache_dir     = f"{test_dir}/cache"

need_rebuild = False

print("[verilua_run] prjdir => ", prj_dir)
print("[verilua_run] workdir => ", work_dir)

execute_cmd(f'mkdir -p {work_dir}')
execute_cmd(f'mkdir -p {test_dir}')
execute_cmd(f'mkdir -p {dut_dir}')
execute_cmd(f'mkdir -p {rtl_dir}')
execute_cmd(f'mkdir -p {cache_dir}')

check_files = files + lua_files
check_files.append(top_file)
for file in check_files:
    if not os.path.isfile(file):
        assert False, f"file: {file} does not exist!"

for file in files + lua_files:
    file_name = os.path.basename(file)
    if not os.path.exists(f"{cache_dir}/{file_name}"):
        need_rebuild = True
        execute_cmd(f"cp {file} {cache_dir}/{file_name}")

for file in lua_files:
    file_name = os.path.basename(file)
    if not os.path.exists(f"{test_dir}/{file_name}"):
        execute_cmd(f"cp {file} {test_dir}/")

verilua_home = os.environ["VERILUA_HOME"]
execute_cmd(f"cp {verilua_home}/scripts/makefiles/* {test_dir}")

# find mismatch rtl file
has_mismatch_rtl = False
for file in files:
    file_name = os.path.basename(file)
    if os.path.isfile(f"{cache_dir}/{file_name}"):
        if not filecmp.cmp(file, f"{cache_dir}/{file_name}", shallow=False):
            has_mismatch_rtl = True

# update mismatch file
if has_mismatch_rtl:
    for file in files:
        file_name = os.path.basename(file)
        execute_cmd(f"cp {file} {cache_dir}/{file_name}")

# find mismatch lua file
has_mismatch_lua = False
for file in lua_files:
    name = os.path.basename(file)
    if not filecmp.cmp(file, f"{cache_dir}/{name}", shallow=False):
        has_mismatch_lua = True

# update mismatch file
if has_mismatch_lua:
    for file in lua_files:
        execute_cmd(f"cp {file} {test_dir}/")

if args.tb_gen_args != "":
    local_parser = argparse.ArgumentParser(description="", add_help=False)
    local_parser.add_argument('--custom-code', '-cc', dest="custom_code", type=str, help='input custom code file, will be inserted in somewhere of the testbench')
    local_args, unknown = local_parser.parse_known_args(args.tb_gen_args.split())
    if local_args.custom_code != None:
        custom_code_file = os.path.abspath(local_args.custom_code)
        name = os.path.basename(custom_code_file)
        if not os.path.exists(f"{cache_dir}/{name}"):
            need_rebuild = True
            execute_cmd(f"cp {custom_code_file} {cache_dir}/{name}")
            execute_cmd(f"rm {cache_dir}/*.custom_code_use")
            execute_cmd(f"touch {cache_dir}/{name}.custom_code_use")
        if not filecmp.cmp(custom_code_file, f"{cache_dir}/{name}", shallow=False):
            need_rebuild = True
            execute_cmd(f"cp {custom_code_file} {cache_dir}/{name}")
        if not os.path.exists(f"{cache_dir}/{name}.custom_code_use"):
            need_rebuild = True
            execute_cmd(f"rm {cache_dir}/*.custom_code_use")
            execute_cmd(f"touch {cache_dir}/{name}.custom_code_use")
    

if has_mismatch_rtl:
    need_rebuild = True

if need_rebuild:
    for file in files:
        execute_cmd(f"cp {file} {rtl_dir}")

verilua_cfg_gen_file = f"{test_dir}/verilua_cfg_unknown.lua"
verilua_cfg_lua = f"""
basic = {{
    test_dir = os.getenv("$PWD"),
    top = "tb_top",
    simulator = "{args.sim}",
    mode = "normal",
    script = "{test_dir}/{os.path.basename(args.lua_main)}",
    period = 10,
    unit = "ns",
    seed = 0,
    attach = false,
    enable_shutdown = true,
    shutdown_cycles = {args.shutdown},
    srcs = {{
        "./?.lua",
    }},
}}
"""

os.environ['SIM']         = args.sim
os.environ['VERILUA_CFG'] = verilua_cfg_gen_file

verilua_cfg_lua_file = f'{test_dir}/verilua_cfg.lua'
with open(verilua_cfg_lua_file, 'w', encoding='utf-8') as file:
    file.write(verilua_cfg_lua)

ret = execute_cmd(f"cd {test_dir}; verilua_gen_cfg")
if ret.stderr:
    assert False, f"==> {ret.stderr}"

if not os.path.exists(f"{test_dir}/sim_build"):
    need_rebuild = True

print("[verilua_run] args =>", args)
print("[verilua_run] has_mismatch_rtl =>", has_mismatch_rtl)
print("[verilua_run] has_mismatch_lua =>", has_mismatch_lua)
print("[verilua_run] need_rebuild =>", need_rebuild)

if args.sim == "vcs":
    if not os.path.isfile(f"{test_dir}/sim_build/simv"):
        need_rebuild = True
elif args.sim == "verilator":
    if not os.path.isfile(f"{test_dir}/sim_build/Vtb_top"):
        need_rebuild = True

# create a clean.sh + build.sh + run.sh that can be used by user to manually run the simulation without using verilua_run
clean_sh=f"""
#!/usr/bin/env bash
export VERILUA_CFG={verilua_cfg_gen_file}
export SIM={args.sim}
make {args.makefile_args} clean
"""
build_sh=f"""
#!/usr/bin/env bash
export VERILUA_CFG={verilua_cfg_gen_file}
export SIM={args.sim}
make {args.makefile_args} build | tee build.log
"""
run_sh=f"""
#!/usr/bin/env bash
export VERILUA_CFG={verilua_cfg_gen_file}
export SIM={args.sim}
make {args.makefile_args} run | tee run.log
"""

scripts = [(clean_sh, "clean.sh"), (build_sh, "build.sh"), (run_sh, "run.sh")]
for (script, name) in scripts:
    with open(f"{test_dir}/{name}", 'w', encoding='utf-8') as file:
        file.write(script)
    execute_cmd(f"chmod 777 {test_dir}/{name}")
    
# create file list
execute_cmd(f'find {dut_dir} -name "*.v" -or -name "*.sv" -or -name "*.svh" > {test_dir}/filelist.f')

if need_rebuild or args.rebuild:
    if not args.no_generate_tb:
        ret = execute_cmd(f"/usr/bin/env python3 $VERILUA_HOME/scripts/testbench_gen.py -f {top_file} --top {args.top} --nodpi --dir {dut_dir} {args.tb_gen_args}")
        if ret.stderr:
            assert False, f"==> {ret.stderr}"
    
    print("[verilua_run] start build...")
    ret = execute_cmd_pipe(f"cd {test_dir}; make {args.makefile_args} clean; make {args.makefile_args} build | tee build.log")
    if isinstance(ret, int) and ret != 0:
        assert False, "build failed!"
    if not isinstance(ret, int) and ret.stderr != None and not ("rm: cannot remove" in ret.stderr):
        assert False, f"build failed! ==> {ret.stderr}"
    if execute_cmd(f'grep "BUILD SUCCESS" {test_dir}/build.log -q; echo $?').stdout.strip("\n") == "1":
        assert False, "build failed!"    

    print("[verilua_run] start run...")
    execute_cmd_pipe(f"cd {test_dir}; export VERILUA_CFG={verilua_cfg_gen_file}; export SIM={args.sim}; make {args.makefile_args} run | tee run.log")
else:
    print("[verilua_run] start run...")
    execute_cmd_pipe(f"cd {test_dir}; export VERILUA_CFG={verilua_cfg_gen_file}; export SIM={args.sim}; make {args.makefile_args} run | tee run.log")

